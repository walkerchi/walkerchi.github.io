{
    "componentChunkName": "component---src-templates-blog-template-blog-template-jsx",
    "path": "/blog/Engineering/Computer/Composition/hust_pa",
    "result": {"data":{"markdownRemark":{"rawMarkdownBody":"\n\n\n<h1>\n    <span style=\"text-decoration:line-through;display:inline-box\">ICS PA 2019</span>\n    <span>HUST PA</span>\n</h1>\n\n****\n$walkerchi\\cdot 2022-1-9$\n****\n照着NJU-PA做就好，[感谢汪先奇奆佬手把手入门教程](https://zhuanlan.zhihu.com/p/413911195)，整个过程非常折磨，有的时候为了实现一个简单的功能可以反汇编跟踪到了13层函数调用(没错，就是printf)。 有些库函数注释都是上个世纪70年代的，实现过程复杂繁琐，非常多无用功，源代码改进空间还是很大的。这个项目主要还是告诉我们整个计算机系统如何运行，所以过分纠结代码风格会给人带来无穷的痛苦:broken_heart:。跟我一同过来交换的其他学院同学都在德国法国荷兰玩，而我把自己关在家里写PA :shit:。这个Project教导我最多的不是计算机，而是如何心平气和处事:pray:。定乎内外之分，辩护荣辱之境，如空无象，湛然圆满。\n\n<img src=\"https://s2.loli.net/2022/01/10/ohAz19NgHxL7nTQ.jpg\" style=\"zoom:30%;\" />\n\n****\n## 0.PA0 环境配置\n这个项目在 WSL2 Ubuntu20.04 上完成，会遇到很多坑，毕竟WSL不是真正的虚拟机。\n### 0.0克隆仓库\n这一步在校外的同学需要通过学校VPN链接。\n在做PA时我人在德国，幸好之前为了做科研办过VPN，现在就方便一些。\n```\ngit clone https://course.cunok.cn/pa/ics2019_1.git/\n```\n在阅读Makefile源代码后我们可以发现在每次make后都会自动更新到git仓库，十分方便。但同时这也意味着Makefile错综复杂，牵一发而动全身。\n### 0.1配置环境变量\n```bash\nexport STUID=UXXXXXXXXX              #学号，用于提交\nexport STUNAME=XXX                   #姓名，用于提交\nexport ICS_HOME=./ics2019            #ics2019 根目录位置，方便修改目录位置\nexport NANO_HOME=ICS_HOME/nanos-lite #nanos-lite 简易操作系统 文件夹位置\nexport NAVY_HOME=ICS_HOME/navy-apps  #navy-apps 运行软件 文件夹爱位置\nexport NEMU_HOME=ICS_HOME/nemu       #nemu 简易指令集 文件夹位置\nexport AM_HOME=ICS_HOME/nexus-am     #nexus-am 简易裸机 文件夹位置 \n```\n建议写在**~/.bashrc**中\n\n## 1.PA1 NEMU入门\n\n### 1.1.简易调试器\n\n这里只用简单阅读一下 `nemu/src/monitor/debug/*` 的代码并补全就好。\n\n不过在`info r`指令中需要用到 `nemu/src/isa/riscv32/reg.c`中的`isa_reg_display`函数，这个函数得自己补全。\n\n这个后面好像没怎么用到，可能是我打开的方式不对:sweat_smile:\n\n最难的莫过于p的实现，考验一些编译原理，简单的表达式可以使用逆波兰式的求解方法，但是这个需要支持寄存器与指针访问，所以不同，必须按照文档上使用递归求解。\n\n|   命令   |            说明             |\n| :------: | :-------------------------: |\n|   help   |            帮助             |\n|    c     |          继续运行           |\n|    q     |            退出             |\n|  si [N]  |    单步执行N步，默认为1     |\n| info r/w |    打印寄存器/监视点信息    |\n|  p EXPR  |      求出表达式EXPR值       |\n| x N EXPR | 从EXPR开始打印内存N个字长值 |\n|   d N    |     删除序号为N的监视点     |\n|  w EXPR  |   当EXPR为true时程序暂停    |\n\n### 1.2.测试\n`nemu/`目录下\n`make ISA=$ISA run`\n\n### 1.3.注意事项\n0. 学会阅读Makefile，在做PA1、PA2的时候后，我遇到的大部分是Makefile报错，由于之前没有注意在意语言，所以花了很多功夫来学习Makefile.(:sweat_smile:论一个有包管理器和项目管理器语言的重要性，这里推荐RUST、GO、JS，Python就算了，比同为动态语言的JS效率低到不知道哪里去了，除非你numba或者cython很溜，希望华科以后出一个更friendly一点的完爆南大)\n1. 第一次make会遇到包未安装的情况，按照google上一项一项解决就好了\n2. RTFM **R**ead **T**he **F**ucking **M**anual 很多关键问题文档上一带而过，然后放一句RTFM让人读手册，给我TM整无语了:sweat_smile:，多说两句话又不是少几年寿命。\n****\n\n## 2.PA2 NEMU+NEXUS-AM\n\n这个就是实打实的实现RISCV32了，逐渐开始硬核。因为C没有接口（虚类、虚函数），所以需要通过一系列让我我开眼的宏定义来达到类似的效果。\n\n这里说一下主要的运行流程。`nemu/src/monitor/monitor.c`中的`cpu_exec`调用了`nemu/src/cpu/cpu.c`中的`exec_once`，这个函数又调用了`nemu/src/isa/riscv32/exec/exec.c`中的`void isa_exec(vaddr_t *pc)`,  该函数中的主要执行函数`static inline void idex(vaddr_t *pc, OpcodeEntry *e)`和宏`IDEX`都定义在`nemu/include/cpu/exec.h`中。\n\n```mermaid\ngraph LR\nsubgraph nemu\nA[cpu_exec]\nsubgraph monitor\n    subgraph monitor.c\n        A\n    end\nend\nB[exec_once]\nC[isa_exec]\na[\"make_DHelper(...)\"]\nb[\"make_EHelper(...)\"]\nsubgraph src\n\tsubgraph cpu\n        subgraph cpu.c\n            A-->B\n        end\n    end\n    subgraph isa/riscv32\n    \tsubgraph exec\n            subgraph exec.c\n                B-->C\n            end\n    \tend\n    \tsubgraph docde.c\n    \t\tC-->a\n    \tend\n    \tsubgraph all-instr.h\n    \t\tC-->b\n    \tend\n    end\nend\nD[idex]\nE[IDEX]\nsubgraph include/cpu\n\tsubgraph exec.h\n\t\tC-->D\n\t\tC-->E\n\tend\nend\nend\nstyle nemu fill:DarkGray \n```\n\n\n\n取址阶段已经在`void isa_exec(vaddr_t *pc)`中帮我们实现好了，我们只需要实现所有指令的译码和执行就可以了。为了使用我们在译码和执行定义的函数，我们也需要对`nemu/src/isa/riscv32/exec/exec.c`中的分发也就是`static OpcodeEntry opcode_table`进行修改\n\n这里放上所有需要实现的指令以供参考。\n\n![](https://s2.loli.net/2022/01/09/5VrksKp3RI4MedH.png)\n\n![](https://s2.loli.net/2022/01/09/R7MOlTpjz1unV2I.png)\n\n\n### 2.1.ID译码\n\n**NEMU**的译码主要通过`nemu/src/isa/riscv32/decode.c`来实现。\n\n在`enmu/src/isa/riscv32/exec/exec.c`中`opcode_table`数组的每一个`IDEX`（不为`EMPTY`）都调用了译码函数（第一个参数）和执行函数（第二个参数）\n\n其中比较费解的是`make_DHelper`，这个宏是为了保证函数接口的一致，在`nemu/include/cpu/decode.h`中定义的，函数输入接口为`(vaddr *pc)`\n\n![RISCV32-TPYE](https://s2.loli.net/2022/01/09/gjC64M837ZRzywB.png)\n\nRISCV32  指令可以大致分为$R,I,S,B,U,J$五种指令，但是这些指令有些变体，所以在`nemu/src/isa/riscv32/decode.c`中追加实现时需要更多的函数\n\n### 2.2.EX执行\n\n**NEMU**的执行分散到了`nemu/src/isa/riscv32/exec`文件夹下的所有文件里，在`all-instr.h`里进行声明，剩下的`*.c`文件里看个人喜好填写函数实现，可以全部写在一个文件里，也可以按照功能进行分类。与`make_DHelper`类似，`make_EHelper`被定义在`nemu/include/cpu/exec.h`中\n\n在这里我认为需要解释一下`rtl_lr`和`rtl_sr`两个函数，他们分别定义在`nemu/src/isa/riscv32/include/isa/rtl.h`文件中，主要作用是对对应序号的寄存器做$load$或者$save$操作，这样可以保证寄存器内数据的安全。\n\n有的结果不能一次得到，因此往往通过中间寄存器`s0`来暂存。\n\n在实现CSR寄存器时，由于没有看RISCV32手册，都是通过反汇编来观察的，总结出来了一下规律：\n\n| CSR寄存器 | CSR寄存器序号 |\n| :-------: | :-----------: |\n|  SSTATUS  |     0x100     |\n|   STVEC   |     0x105     |\n|   SEPC    |     0x141     |\n|  SCAUSE   |     0x142     |\n|   SATP    |     0x180     |\n\n关于CSR指令，网上资料少而散，而且有的有误导，这里我统一整理一下。\n\n首先，CSR指令都是I型指令，这里的对CSRR的索引是找CSR寄存器序号对应的CSR寄存器，因此还需要自己实现序号和寄存器之间映射的函数。 \n\n1. `csrrw imm rd rs1` \n\n   `CSRR[imm]->rd, rs1->CSRR[imm]`\n\n2. `csrrs imm rd rs1`\n\n   `CSRR[imm]->rd, rs1|CSRR[imm]->CSRR[imm]`\n\n3. `csrrc`\n\n   `CSRR[imm]->rd, (~rs1)&CSRR[imm]->CSRR[imm]`\n\n4. `csrrwi imm1 rd imm2`\n\n   `CSRR[imm1]->rd, imm2->CSRR[imm1]`\n\n5. `csrrsi imm1 rd imm2`\n\n   `CSRR[imm1]->rd, imm2|CSRR[imm1]->CSRR[imm1]`\n\n6. `csrrci imm1 rd imm2`\n\n   `CSRR[imm1]->rd, (~imm2)&CSRR[imm1]->CSRR[imm1]`\n\n7. `ecall`\n\n   `pc+4->CSRR[SEPC], a7->CSRR[SCAUSE], CSRR[STVEC]->pc`\n\n8. `sret`\n\n   `CSRR[SEPC]->pc`\n\n注意，`nemu/src/isa/riscv32/include/isa/reg.h`和`nemu/src/isa/riscv32/reg.c`都没有实现`CSR`寄存器，需要自己补上去\n\n### 2.3.输入输出\n\n这里需要分别实现键盘、计时器和视频的IO，他们在文件夹`nexus-am/am/src/nemu-common`文件夹下，分别为`nemu-input.c`，`nemu-timer.c`和`nemu-video.c`\n\n`nexus-am/am/src/nemu-common/ioe.c`中的`_io_read`和`_io_write`函数会转发信息到以上的三个函数。\n\n值得注意的是，因为我是用的Vscode--RemoteWSL--WSL2的开发模式，所以SDL库是无法检测到键盘信息的，我还特意写了一段代码进行测试。如果你同样使用的WSL2，请下载远程桌面，通过桌面进行调试，我是用的是vnc+xrdp.\n\n1. **`size_t __am_input_read(uintptr_t reg, void *buf, size_t size) `**\n\n​\t\t在`nemu-input.c`中我们不需要考虑键盘的掩码，只需要从`0xa1000060`读出值，判断是否为空和赋\t\t值就好了。\n\n2. **`size_t __am_timer_read(uintptr_t reg, void *buf, size_t size)`**\n\n​\t\t在`nemu-timer.c`中只需要实现`_DEVERG_TIMER_UPTIME`的情况，从`0xa1000048`读出时间，减去开机\t\t时间赋值给`uptime->lo`就可以了。\n\n3. **`size_t __am_video_read(uintptr_t reg, void *buf, size_t size)`**\n\n​\t\t在`nemu-video.c`中是个画矩形函数，将矩形对应位置的图像信息写入 `0xa0000000`。这个个人感觉\t\t非常低效，使得后面PA3的接口调用效率大大降低。\n\n### 2.4 klib\n\n​\t为了保证测试的顺利，还需要实现`nexus-am/libs/klib/src`下的一些函数\n\n**`nexus-am/libs/klib/src/stdio.c`**\n\n1. `int my_printf(const char *fmt, ...)`\n\n   我就直接调用`my_vsprintf`了\n\n2. `int my_vsprintf(char *out, const char *fmt, va_list ap)`\n\n   直接上代码\n\n   ```c\n   int itoa_helper(char *out, int ptr, uint32_t valint, int base){\n     assert(valint>=0);\n     int stack[128],sptr=0;\n     if(valint==0)out[ptr++]='0';\n     else{\n       for(;valint;stack[sptr++]=valint%base,valint=valint/base);\n       for(--sptr;sptr>=0;--sptr){\n         if(stack[sptr]<10)out[ptr++]=stack[sptr]+'0';\n         else if(stack[sptr]<16)out[ptr++]=stack[sptr]-10+'a';\n         else{\n           assert(0);\n         }\n       }\n     }\n     return ptr;\n   }\n   int my_vsprintf(char *out, const char *fmt, va_list ap) {\n     int ptr=0;\n     for(;*fmt;++fmt){\n       if(*fmt!='%')out[ptr++]=*fmt;\n       else{\n         switch(*(++fmt)){\n           case 'c':{\n             char c = va_arg(ap,int);\n             out[ptr++]=c;\n             break;\n           }\n           case 'd':{\n             int valint=va_arg(ap,int);\n             if(valint<0){\n               out[ptr++]='-';\n               valint=-valint;\n             }\n             ptr = itoa_helper(out,ptr,valint,10);\n             break;\n           }\n           case 'x':{\n             uint32_t valint=va_arg(ap,uint32_t);\n             ptr = itoa_helper(out,ptr,valint,16);\n             break;\n           }\n           case 's':{\n             const char* valstr=va_arg(ap,char*);\n             for(;*valstr;out[ptr++]=*valstr++);\n             break;\n           }\n           case 'f':{\n             float valflt=va_arg(ap,float);\n             if(valflt<0){\n               out[ptr++]='-';\n               valflt=-valflt;\n             }\n             int tmpint=(int)valflt;\n             int tmpflt=(int)(10000*(valflt-tmpint));\n             ptr=itoa_helper(out,ptr,tmpint,10);\n             out[ptr++]='.';\n             ptr=itoa_helper(out,ptr,tmpflt,10);\n             break;\n           }\n           default:{\n             out[ptr++]='%';\n             out[ptr++]=*fmt;\n             break;\n           }\n         }\n       }\n     }\n     out[ptr]=0;\n     return ptr;\n   }\n   ```\n\n3. `int my_sprintf(char *out, const char *fmt, ...)`\n4. `int my_snprintf(char *out, size_t n, const char *fmt, ...) `\n\n**`nexus-am/libs/klib/src/string.c`**\n\n1. `size_t my_strlen(const char *s)`\n\n2. `char *my_strcpy(char* dst,const char* src)`\n\n3. `char* my_strncpy(char* dst, const char* src, size_t n)`\n\n4. `char* my_strcat(char* dst, const char* src)`\n\n5. `int my_strcmp(const char* s1, const char* s2)`\n\n6. `int my_strncmp(const char* s1, const char* s2, size_t n)`\n\n7. `void* my_memset(void* v,int c,size_t n)`\n\n   可以循环展开，也可以把一个字节变成四字节，太慢了这个函数，网上有超越原版c语言`memset`的写法\n\n8. `void* my_memcpy(void* out, const void* in, size_t n)`\n\n   同上\n\n9. `void* my_memcpy(void* out, const void* in, size_t n)`\n\n10. `int my_memcmp(const void* s1, const void* s2, size_t n)`\n\n### 2.5.测试\n\n1. 在`nexus-am/tests/cputest` 中执行`make ALL=xxx run`来测试cpu的运行的正确性,这里的`xxx`可以使`nexus-am/tests/cputest/tests`目录下的任何一个名字。\n\n2. 在`nexus-am/tests/amtest/`中执行`make ARCH=native mainargs=H run`来测试输入输出的正确性，其中`mainargs`的参数可以根据测试的项目相应修改，也可以在`nemu/`目录下运行`bash runall.sh ISA=riscv32`来进行批测试。\n3. 在`nexus-am/apps/*`文件夹下有各种测试可以进入文件夹运行`make run`来测试程序\n\n### 2.5.注意事项\n\n1. 使用WSL2的同学需要安装远程桌面来解决SDL转发的问题，目前不知道如何通过Vscode 的RemoteWSL转发\n1. `nemu/src/isa/riscv32/include/isa/reg.h`和`nemu/src/isa/riscv32/reg.c`都没有实现`CSR`寄存器，需要自己补上去\n\n****\n## 3.PA3 Nanos-Lite\n\n### 3.1.系统调用\n\n首先在`nanos-lite/`目录下运行`make ARCH=riscv32 run`试一下（注意开`nemu/include/common.h`中的`DEBUG`，这样我们就可以打印日志来debug了）。通过观察`nanos-lite/nemu-log.txt`和`nanos-lite-riscv32-nemu.txt`以及`ramdisk.asm`来进行debug。\n\n**编译过程**这里说一下主要的编译流程`nanos-lite/build/nano-lite-riscv32-nemu.txt`作为操作系统会运行`nanos-lite/build/ramdisk.asm`中的程序，通过观察`nanos-lite/Makefile`可以发现，每次`make ARCH=riscv32 run`会编译`navy-apps/tests/*`和`navy-apps/apps/*`并放入`navy-apps/fsimg`，然后全部copy过来作为`nanos-lite/build/ramdisk.img`，我们可以使用这个riscv工具链来反汇编`nanos-lite/build/ramdisk.img`来查看内容\n\n```bash\nriscv64-unknown-elf-objdump -d nanos-lite/build/ramdisk.img > nanos-lite/build/ramdisk.asm\n```\n\n**运行过程**再来说一下运行流程，首先`nexus-am/am/src/riscv32/nemu/boot/start.S`会运行`_start`函数，这个函数会跳转到`nexus-am/am/src/riscv32/nemu-common/trm.c`的`void _trm_init()`，这个函数会调用`nanos-lite/src/main.c`中的`int main(const char *args)`，也就是**NANOS**的入口。在完成一些列初始化时，在`nanos-lite/src/proc.c`中的`void init_proc()`开始从`ramdisk.img`装载程序，并跳转该程序进行执行。\n\n```mermaid\ngraph  LR \nA[_start]\nB[_trim_init]\nC[main]\nD[init_proc]\nE[*]\nsubgraph nexus-am\n\tsubgraph am/src\n    subgraph riscv32/nemu/boot\n    subgraph start.S\n        A\n    end\n    end\n    subgraph nemu-common\n    subgraph trm.c\n        A-->B\n    end\n   \tend\n   end\nend\nsubgraph nanos-lite\n\tsubgraph src\n    subgraph main.c\n\t    B-->C\n    end\n    subgraph proc.c\n    \tC-->D\n    end\n    end\nend\nsubgraph navy-apps\n\tsubgraph tests\n\t\tD-->E\n\tend\nend\nstyle nanos-lite fill: coral\nstyle nexus-am fill: cornflowerblue\nstyle navy-apps fill: Aquamarine \n```\n\n\n\n**系统调用过程**在`ramdisk.img`中的程序使用系统调用时，一般是`navy-apps/libs/libc`中的库函数，这些函数会经过层层绕绕后调用`navy-apps/libs/libos/src/nanos.c`中的一些函数，这些函数都会调用`intptr_t _syscall_(intptr_t type, intptr_t a0, intptr_t a1, intptr_t a2)`，这个函数会对寄存器进行赋值并执行`ecall`。然后会进入`nexus-am/am/src/riscv32/nemu/trap.S`的`__am_asm_trap`函数，这个函数会将所有寄存器压栈，并将栈顶作为参数调用`nexus-am/am/src/riscv32/nemu/cte.c`中的`__am_irq_handle`，这个函数会调用在**NANOS**中定义的`user_handler`也就是`nanos-lite/src/irq.c`中的`static _Context* do_event(_Event e, _Context* c)`函数，这个函数又会调用`nanos-lite/src/syscall.c`中的`_Context* do_syscall(_Context* c)`函数来在操作系统层面处理。\n\n```mermaid\ngraph LR\nA[printf,malloc,...]\nB[_exit]\nC[_open]\nD[_write]\nE[_sbrk]\nF[_read]\nG[_close]\nH[_lseek]\nI[_execve]\nJ[_...]\nK[_syscall_]\nsubgraph navy-apps\n\tsubgraph libs\n\t\tsubgraph libc\n\t\t\tA\n\t\tend\n\t\tsubgraph libos\n\t\t\tA-->B\n\t\t\tA-->C\n\t\t\tA-->D\n\t\t\tA-->E\n\t\t\tA-->F\n\t\t\tA-->G\n\t\t\tA-->H\n\t\t\tA-->I\n\t\t\tA-->J\n\t\t\tB-->K\n\t\t\tC-->K\n\t\t\tD-->K\n\t\t\tE-->K\n\t\t\tF-->K\n\t\t\tG-->K\n\t\t\tH-->K\n\t\t\tI-->K\n\t\t\tJ-->K\n\t\tend\n\tend\nend\na[__am_asm_trap]\nb[__am_irq_handle]\nsubgraph nexus-am\n\tsubgraph am/src/riscv32/nemu\n\tsubgraph trap.S\n\t\tK-->a\n\tend\n\tsubgraph cte.c\n\t\ta-->b\n\tend\n\tend\nend\nc[do_event]\nd[do_syscall]\nsubgraph nanos-lite\n\tsubgraph src\n\tsubgraph irq.c\n\tb-->c\n\tend\n\tsubgraph syscall.c\n\tc-->d\n\tend\n\tend\nend\nstyle nanos-lite fill: coral\nstyle nexus-am fill: cornflowerblue\nstyle navy-apps fill: Aquamarine \n```\n\n\n\n这一阶段，需要实现`nanos-lite/src/irq.c`中的事件分发,以及`nanos-lite/src/syscall.c`中的系统调用，为了使得`navy-apps/tests/hello`能正确输出。需要实现`SYS_exit`，`SYS_yield`，`SYS_write`，`SYS_brk`，`SYS_execve`。这里通过`libc`中源代码我们对`libc`中的`printf`做一个简单的分析，在进入操作系统层面前`printf`一共使用了13层调用:fearful: WTF!\n\n```mermaid\nflowchart LR\nA[printf]\nB[_vfprintf_r]\nC[__sfputs_r]\nD[_fputc_r]\nE[_putc_r]\nF[__swbuf_r]\nG[_fflush_r]\nH[__sflush_r]\nI[__swrite]\nJ[_write_r]\nK[_write]\nL[__am_trap_handle]\nM[__am_irq_handle]\nN[do_syscall]\nZ[do_event]\nsubgraph libc\nA-->B\nB-->C\nC-->D\nD-->E\nE-->F\nF-->G\nG-->H\nH-->I\nI-->J\nend\nsubgraph libos\nJ-->K\nend\nsubgraph trap.S\nK-->L\nend\nsubgraph cte.c\nL-->M\nend\nsubgraph irq.c\nM-->Z\nend\nsubgraph syscall.c\nZ-->N\nend\n```\n\n1. `SYS_exit`\n\n​\t直接调用`_halt()`就行\n\n2. `SYS_yield`\n\n   直接调用`_yield()`就行\n\n3. `SYS_write`\n\n   对于`fd`为1或者2，则直接输出到`stdout`就行，当`fd`为其它时调用`fd_write`写入到文件\n\n4. `SYS_brk`\n\n   这里没有太看懂Gitbook上的内容，我的理解是将`_heap.start`增加`GPR2`个大小，返回之前的`_heap.start`\n   \n   后来通过阅读`nexus-am/am/src/riscv32/nemu/boot/loader.ld`以及伟哥的帮助，终于弄懂了一些\n   \n   这里放上`loader.ld`的代码\n   \n   ```c\n   SECTIONS {\n     . = 0x80100000;\n     .text : {\n       *(entry)\n       *(.text)\n     }\n     etext = .;\n     _etext = .;\n     .rodata : {\n       *(.rodata*)\n     }\n     .data : {\n       *(.data)\n     }\n     edata = .;\n     _data = .;\n     .bss : {\n   \t_bss_start = .;\n       *(.bss*)\n       *(.sbss*)\n       *(.scommon)\n     }\n     _stack_top = ALIGN(4096);\n     . = _stack_top + 0x8000;\n     _stack_pointer = .;\n     end = .;\n     _end = .;\n     _heap_start = ALIGN(4096);\n     _heap_end = 0x88000000;\n   }\n   ```\n   \n   可以看到程序一共分为几大段`.text`，`.roddata`，`.data`，`.bss`，`.stack`，`.heap`，前面四段在编译完后大小就可以确定了，因此整个程序空间剩下的作为运行时变化的`.stack`和`.heap`段使用。整个程序运行空间大小为`0x880000000-0x80100000`，其中栈和堆从两边分别向对侧生长，界限由`_end`控制。为了确认我们的想法，可以观察一下`nexus-am/am/src/nemu-common/trm.c`中对`_heap`的定义\n   \n   ```c\n   /*\n   nexus-am/am/src/nemu-common/trm.c\n   */\n   #include <am.h>\n   #include <nemu.h>\n   \n   extern char _heap_start;\n   extern char _heap_end;\n   int main(const char *args);\n   \n   _Area _heap = {\n     .start = &_heap_start,\n     .end = &_heap_end,\n   };\n   ```\n   \n   可以发现堆的定义就是从`loader.ld`中读取`_heap_start`和`_heap_end`。因此在`nanos.c`中进行修改\n   \n   ```c\n   /*\n   navy-apps/libs/libos/src/nanos.c\n   */\n   extern char end;\n   void *_sbrk(intptr_t increment) {\n     static void* program_break = (uintptr_t)&end;\n     void* old = program_break;\n     if(_syscall_(SYS_brk,program_break+increment,0,0)==0){\n       program_break += increment;\n       return old;\n     }\n     return (void*)-1;\n   }\n   ```\n   \n   `syscall.c`中相应的实现为\n   \n   ```c\n   case SYS_brk:{\n         printf(\"sys brk\\n\");\n         if(c->GPR2<=_heap.start||c->GPR2>=_heap.end){\n           c->GPRx = -1;\n         }\n         break;\n       }\n   ```\n   \n5. `SYS_execve`\n\n   这个是直接调用`naive_loader`就好了，但是在实现`naive_loader`（调用了`loader`）的时候需要对elf文件格式很了解（这个文件格式有很多不合理的地方，历史遗留问题，老屎山了:poop:），可以看看[B站上对这个文件格式的讲解](https://b23.tv/afki9uB)，我这里就直接提供源代码\n\n   ```c\n   static uintptr_t loader(PCB *pcb, const char *filename) {\n     if(filename == NULL){\n       Elf_Ehdr ehdr;\n       ramdisk_read(&ehdr,0,sizeof(Elf_Ehdr));\n       Elf_Phdr phdr[ehdr.e_phnum];\n       ramdisk_read(phdr,ehdr.e_ehsize,sizeof(Elf_Phdr)*ehdr.e_phnum);\n       for(size_t i=0;i<ehdr.e_phnum;++i){\n         if(phdr[i].p_type==PT_LOAD){\n           ramdisk_read((void*)phdr[i].p_vaddr,phdr[i].p_offset,phdr[i].p_memsz);\n           memset((void*)(phdr[i].p_vaddr+phdr[i].p_filesz),0,phdr[i].p_memsz-phdr[i].p_filesz);\n         }\n       }\n       return ehdr.e_entry;\n     }else{\n       int fd = fs_open(filename, 0,0);\n       Elf_Ehdr ehdr;\n       int ret = fs_read(fd, &ehdr,sizeof(Elf_Ehdr));\n       assert(ret!=-1);\n       ret = fs_lseek(fd,ehdr.e_ehsize,SEEK_SET);\n       assert(ret!=-1);\n       Elf_Phdr phdr[ehdr.e_phnum];\n       ret = fs_read(fd,phdr,sizeof(Elf_Phdr)*ehdr.e_phnum);\n       assert(ret!=-1);\n       for(size_t i=0;i<ehdr.e_phnum;++i){\n         if(phdr[i].p_type==PT_LOAD){\n           ret = fs_lseek(fd,phdr[i].p_offset,SEEK_SET);\n           assert(ret!=-1);\n           ret = fs_read(fd,(void*)phdr[i].p_vaddr,phdr[i].p_memsz);\n           assert(ret!=-1);\n           memset((void*)(phdr[i].p_vaddr+phdr[i].p_filesz),0,phdr[i].p_memsz-phdr[i].p_filesz);\n         }\n       }\n       fs_close(fd);\n       return ehdr.e_entry;\n     }\n   \n   }\n   ```\n\n   \n\n值得注意的是`nexus-am/am/include/arc/riscv32-nemu.h`中对`struct _Context`的定义与`nexus-am/am/src/riscv32/nemu/trap.S`中的压栈顺序并不一致，所以我对`struct _Context`的定义做了修改\n\n\n\n### 3.2.文件系统\n\n这里主要实现的是`nanos-lite/src/fs.c` \n\n这里解释一下`nanos-lite/src/files.h`这个文件include在`nanos-lite/src/fs.c`的`file_table`中，所以文件系统的所有文件包含了`file_table`中的以及`files.h`中的。由于我们的一切皆文件，所以还需要在`file_table`中加上`/dev/events`，`/proc/dispinfo`，`/dev/fb`，`dev/fbsync`，`/dev/tty`。这些虚拟文件分别在`fs_read`，`fs_write`中做特殊处理。为了处理这些特殊文件，我们会用到`nanos-lite/src/device.c`中的函数，这些函数只需要调用`nexus-am/am/am.h`中的`_io_read`就可以完成设备的读写操作，顺带提一句，这里的`fb_write`真的是蛋疼，在`_io_read`接口把线性空间写操作改为长方形写操作，在`nexus-am/am/src/nemu-common/nemu-video.c`的`__am_video_write`函数中又还原成线性写操作，这不是闲的蛋疼么，是不是闲我们CPU占用太低了拉点CPU占用:sweat_smile:。\n\n`Finfo`结构体中需要增加成员记录文件打开后的偏移位置。值得注意的是，:star:千万不要把文件指针直接返回，结构体在出函数时会自动销毁，建议返回文件在`file_table`中的索引位置。\n\n```mermaid\ngraph LR\nA[\"/proc/dispinfo\"]\nB[\"/dev/events\"]\nC[stdout]\nD[stderr]\nE[\"/dev/fbsync\"]\nF[\"/dev/tty\"]\nG[stdin]\nY[fs_read]\nZ[fs_write]\na[serial_write]\nb[events_read]\nc[dispinfo_read]\nd[fb_write]\ne[fbsync_write]\n_a[_putc]\n_b[_io_read]\n_c[_io_write]\nsubgraph nanos-lite\n\tsubgraph src\n        subgraph fs.c\n            A-->Y\n            B-->Y\n            C-->Z\n            D-->Z\n            E-->Z\n            F-->Z\n        end \n        subgraph device.c\n            Y-->b\n            Y-->c\n            Z-->a\n            Z-->d\n            Z-->e\n        end\n    end\nend\nsubgraph nexus-am\n\tsubgraph am\n\tsubgraph am.h\n        Z-->_a\n        a-->_c\n        d-->_c\n        e-->_c\n        b-->_b\n        c-->_b\n\tend\n\tend\nend\nstyle nanos-lite fill: coral\nstyle nexus-am fill: cornflowerblue\n```\n\n\n\n**特殊文件读写权限**\n\n* Read Only\n\n  `/proc/dispinfo`，`/dev/events`\n\n* Write Only\n\n  `stdout`，`stderr`，`/dev/fb`，`/dev/fbsync`，`/dev/tty`\n\n* Forbidden\n\n  `stdin`\n\n**`/nanos-lite/src/fs.c`**\n\n1. `Finfo`\n\n   ```c\n   typedef struct {\n     char *name;\n     size_t size;\n     size_t disk_offset;\n     size_t open_offset;\n     ReadFn read;\n     WriteFn write;\n   } Finfo;\n   ```\n\n2. `file_table`\n\n   ```c\n   static Finfo file_table[] __attribute__((used)) = {\n     {\"stdin\", 0, 0, 0,invalid_read, invalid_write},\n     {\"stdout\", 0, 0, 0,invalid_read, invalid_write},\n     {\"stderr\", 0, 0, 0,invalid_read, invalid_write},\n     {\"/dev/events\",0,0,0},\n     {\"/proc/dispinfo\",0,0,0},\n     {\"/dev/fb\",0,0,0},\n     {\"/dev/fbsync\",0,0,0},\n     {\"/dev/tty\",0,0,0},\n   #include \"files.h\"\n   };\n   ```\n\n2. `int fs_open(const char* pathname, int flags, int mode)`\n   设置结构体中的`open_offset`为0就好，返回的`fd`最好不是结构体指针，c语言会蛋疼的销毁结构体，最好返回位置索引。\n\n3. `size_t fs_read(int fd, void *buf, size_t len)`\n\n   对于可读特殊文件调用相应的系统函数就好（`events_read`，`dispinfo_read`）\n\n4. `size_t fs_write(int fd, void *buf, size_t len)`\n\n   对于可写特殊文件调用相应的系统函数就好（`_putc`，`fb_write`，`fbsync_write`，`serial_write`）\n\n**`/nanos-lite/src/device.c`**\n\n1. `size_t serial_write(const void *buf, size_t offset, size_t len)`\n\n   调用`_putc`输出到`stdout`。\n\n2. `size_t events_read(void *buf, size_t offset, size_t len)`\n\n   调用`_io_read`读取按键并和掩码`0x7fff`做与运算按照格式输出到`buf`。\n\n3. `size_t dispinfo_read(void *buf, size_t offset, size_t len)`\n\n   在`void init_device()`中一开始就初始化`dispinfo`字符串，这个时候只需要复制到`buf`里即可。\n\n4. `size_t fb_write(void *buf, size_t offset, size_t len)`\n\n   这里我实现了将线性赋值变成了一到三个矩形画图，这个转换真的是闲的蛋疼:sweat:，我直接放代码好了。\n\n   ```c\n   size_t fb_write(void *buf, size_t offset, size_t len) {\n   #ifdef MULTIPROC\n     _yield();\n   #endif\n     offset /=4;\n     //printf(\"fb write buf:0x%x offset:%d len:%d\\n\",buf,offset,len);\n     uint32_t * p=buf;\n     len = min(H*W-offset,len);\n     int ret = len;\n     _DEV_VIDEO_FBCTL_t ctl ;\n     ctl.pixels = p;\n     ctl.x = offset%W;\n     ctl.y =offset/W;\n     ctl.w = W-offset%W;\n     ctl.h = 1,\n     ctl.sync = 0,\n     _io_write(_DEV_VIDEO, _DEVREG_VIDEO_FBCTL, &ctl, sizeof(ctl));\n     \n     ctl.x=0;\n     ctl.y+=ctl.h;\n     len-=ctl.w*ctl.h;\n     p+=ctl.w*ctl.h;\n     if(len/W){\n       ctl.h=len/W;\n       ctl.w =W;\n       ctl.pixels=p;\n       _io_write(_DEV_VIDEO, _DEVREG_VIDEO_FBCTL, &ctl, sizeof(ctl));\n       ctl.y+=ctl.h;\n       len-=ctl.h*ctl.w;\n       p+=ctl.h*ctl.w;\n     }\n   \n     if(len){\n       ctl.pixels = p;\n       ctl.w = len;\n       ctl.h = 1;\n       _io_write(_DEV_VIDEO, _DEVREG_VIDEO_FBCTL, &ctl, sizeof(ctl));\n     }\n     return ret;\n   }\n   ```\n\n5. `size_t fbsync_write(const void *buf, size_t offset, size_t len)`\n\n   这里没啥技术含量，仿照之前的test里面的代码写一写就好了\n\n   ```c\n   size_t fbsync_write(const void *buf, size_t offset, size_t len) {\n    _DEV_VIDEO_FBCTL_t ctl;\n    ctl.pixels = NULL;\n    ctl.x = ctl.y = ctl.w = ctl.h = 0;\n    ctl.sync = 1;\n    _io_write(_DEV_VIDEO, _DEVREG_VIDEO_FBCTL, &ctl, sizeof(ctl));\n    return 0;\n   }\n   ```\n\n   \n\n   \n\n\n值得注意的是，我在WSL中发现`files.h`的`/share/texts/num`文件大小是6000字节，而不是5000字节，猜测与windows系统地`\\n\\r`有关，所以在做`/bin/text`测试时，需要在`navy-apps/tests/text/text.c`修改测试代码\n\n\n\n### 3.3测试\n\n在`nanos-lite/src/proc.c`的`void init_proc()`中，修改`naive_load`的文件就可以了，这些文件可以是`files.h`中的任何可执行文件。如果需要运行PAL(仙剑奇侠传，那么需要下载额外文件到`navy-apps/apps/pal`)\n\n### 3.4.注意事项\n\n1. `nexus-am/am/include/arc/riscv32-nemu.h`中对`struct _Context`的定义与`nexus-am/am/src/riscv32/nemu/trap.S`中的压栈顺序并不一致，所以我对`struct _Context`的定义做了修改\n2. 千万不要把文件指针直接返回，结构体在出函数时会自动销毁，建议返回文件在`file_table`中的索引位置。\n3. 我在WSL中发现`files.h`的`/share/texts/num`文件大小是6000字节，而不是5000字节，猜测与windows系统地`\\n\\r`有关，所以在做`/bin/text`测试时，需要在`navy-apps/tests/text/text.c`修改测试代码\n3. 在debug时，可以修改`navy-apps/tests/*`下的文件来进行错误定位，在编译后，可以使用`riscv64-unkown-elf-objdump`指令来反汇编`navy-apps/fsimg/bin`下的二进制文件进行观察\n\n****\n\n## 4.PA4 NANOS-LITE pro\n\n#### 4.1.多进程\n\n程序加载流程为\n\n```mermaid\ngraph TB\nsubgraph nanos-lite\nsubgraph src\nA[naive_uload]\nB[context_kload]\nC[context_uload]\nsubgraph loader.c\n\tA\n\tB\n\tC\nend\nD[loader]\nsubgraph loader.c\n\tA-->D\n\tC-->D\nend\nend\nend\nE[_kcontext]\nF[_ucontext]\nsubgraph nexus-am\n\tsubgraph am/src/riscv32/nemu\n\t\tsubgraph cte.c\n\t\t\tB-->E\n\t\tend\n\t\tsubgraph vme.c\n\t\t\tC-->F\n\t\tend\n\tend\nend\nstyle nanos-lite fill: coral\nstyle nexus-am fill: cornflowerblue\n```\n\n进程切换的流程为\n\n```mermaid\ngraph LR \nA[_yield]\nB[__am_asm_trap]\nC[__am_irq_handle]\nsubgraph nexus-am\n\tsubgraph am/src/riscv32/nemu\n\t\tsubgraph cte.c\n\t\t\tA\n\t\t\tC\n\t\tend\n\t\tsubgraph trap.S\n\t\t\tA-->B\n\t\t\tB-->C\n\t\tend\n\tend\nend\nD[do_event]\nE[schedule]\nsubgraph nanos-lite\n\tsubgraph src\n\t\tsubgraph irq.c\n\t\t\tC-->D\n\t\tend\n\t\tsubgraph proc.c\n\t\t\tD-->E\n\t\tend\n\tend\nend\nstyle nanos-lite fill: coral\nstyle nexus-am fill: cornflowerblue\n```\n\n所有涉及到的文件就一目了然了\n\n1. **`nexus-am/am/src/riscv32/nemu/trap.S`**\n\n   首先`__am_irq_handle`需要重置`sp`，因为在`__am_irq_hanlde`期间，如果是切换进程，那么`Context`都会改变，所以需要将新的`Context`导出到寄存器\t\n\n   ```\n      mv a0, sp\n      jal __am_irq_handle\n      mv sp, a0\n   ```\n\n2. **`nanos-lite/src/irq.c`**\n\n   `_Context* do_event(_Event e, _Context* c)`当操作系统收到`EVENT_YIELD`时，需要调用`schedule`来切换进程\n\n   ```c\n       case _EVENT_YIELD:{\n         printf(\"event yield\\n\");\n         c=schedule(c);\n         break;\n       }\n   ```\n\n3. **`nanos-lite/src/loader.c`**\n\n   在`context_uload`中，首先使用`loader`将代码段装到`pcb`，不同进程的代码是不同的，然后调用`_ucontext`对上下文进行初始化\n\n\n### 4.2.分页\n\n分页机制就是使用虚拟地址而不是实际地址来，然而并不是所有的虚拟地址都会映射到物理地址。当我们需要使用哪些虚拟地址时便会建立映射。在`rtl_lm`或者`rtl_sm`访问地址的时候会根据一定策略来将虚拟地址转换为物理地址。\n\n建立映射的位置有两个，一个是在程序加载的时候，还有一个是在程序运行时申请空间的时候。\n\n####  4.2.1 程序加载\n\n对于程序加载主要流程如下，`nanos-lite/src/loader.c`中按照页大小对程序进行读取 ，每读取一页通过调用`_map`建立虚拟地址到物理地址的映射存入`c->ptr`中（这个也是页目录）。注意编译时需要将`navy-apps/Makefile.compile`中`VME=enable`前的注释符号去掉，让Makefile将程序映射到`0x40000000`开头的虚拟地址空间。\n\n```mermaid\ngraph LR\nA[context_uload]\nB[loader]\nC[new_page]\nsubgraph nanos-lite\n\tsubgraph src\n\t\tsubgraph loader.c \n\t\t\tA-->B\n\t\tend\n\t\tsubgraph mm.c\n\t\t\tB-->C\n\t\tend\n\tend\nend\nD[_map]\nsubgraph nexus-am\n\tsubgraph am/src/riscv32/nemu\n\t\tsubgraph vme.c\n\t\t\tB-->D\n\t\tend\n\tend\nend\nstyle nanos-lite fill: coral\nstyle nexus-am fill: cornflowerblue\n```\n\n1. **`static uintptr_t loader(PCB *pcb, const char *filename) `**\n\n   在加载程序的时候根据elf将每个块分页，读入分配物理地址，并调用`_map`来进行映射\n\n2. **`int _map(_AddressSpace *as, void *va, void *pa, int prot)`**\n\n    根据页目录基地址`as->ptr`，建立`va`到`pa`的映射，这里我规定`va`和`pa`都是页起始地址，也就意味着他们的低12位为0\n\n#### 4.2.2.程序运行\n\n在程序运行时，像`malloc`之类的函数会动态的申请新的虚拟地址，因此我们还需要对这部分动态申请的虚拟地址建立映射。申请空间会调用`SYS_brk`因此在调用`SYS_brk`的时候我们分配物理地址并进行映射就好了\n\n```mermaid\ngraph LR \nA[_sbrk]\nB[_syscall_]\nsubgraph navy-apps\n\tsubgraph libs/libos/src\n\t\tsubgraph nanos.c\n\t\t\tA-->B\t\n\t\tend\n\tend\nend\nC[__am_asm_trap]\nD[__am_irq_handle]\nH[_map]\nsubgraph nexus-am\n\tsubgraph am/src/riscv32/nemu\n\t\tsubgraph trap.S\n\t\t\tB-->C\n\t\tend\n\t\tsubgraph cte.c\n\t\t\tC-->D\n\t\tend\n\t\tsubgraph vme.c\n\t\t\tH\n\t\tend\n\tend\nend\nE[do_event]\nF[do_syscall]\nG[mm_brk]\nI[new_page]\nsubgraph nanos-lite\n\tsubgraph src\n\t\tsubgraph irq.c\n\t\t\tD-->E\n\t\tend\n\t\tsubgraph syscall.c\n\t\t\tE-->F\n\t\tend\n\t\tsubgraph mm.c\n\t\t\tF-->G\n\t\t\tG-->I\n\t\t\tG-->H\n\t\tend\n\tend\nend\nstyle nanos-lite fill: coral\nstyle nexus-am fill: cornflowerblue\nstyle navy-apps fill: Aquamarine \n```\n\n1. **`mm_brk(uintptr_t brk, intptr_t increment)`**\n\n   为`[brk,brk+increment]`的虚拟空间分配物理空间并建立映射，如果有的虚拟页已经建立映射则直接跳过。\n\n#### 4.2.3.运行时访存\n\n除了建立映射， 在访问时还需要根据映射来进行虚地址到物理地址的转换。因此还需要在地址访问时进行转化。转换的依据是`satp`寄存器，最高位为模式为，`1`时为开启分页，`0`为关闭分页。`PPN`为页目录基地址右移12位，可以将`satp<<12`得到`pdir`页目录基地址。\n\n![](https://s2.loli.net/2022/01/14/G7yqcMgC3nLmKOR.jpg)\n\n在执行`isa_vaddr_read`/`isa_vaddr_write`时，需要判断是否开启分页 ，如果开启分页则调用`page_translate`来映射地址再进行读取，需要注意跨页情况。\n\n```mermaid\ngraph LR \nA[isa_vaddr_read]\nB[isa_vaddr_write]\nC[page_translate]\nD[paddr_read]\nE[paddr_write]\nsubgraph nemu\n\tsubgraph src\n        subgraph isa/riscv32\n            subgraph mmu.c\n                A-->C\n                B-->C\n            end\n        end\n   \t\tsubgraph memory\n   \t\t\tsubgraph memory.c\n   \t\t\t\tA-->D\n   \t\t\t\tB-->E\n   \t\t\tend\n   \t\tend\n   end\nend\nstyle nemu fill:DarkGray \n```\n\n1. **`paddr_t page_translate(vaddr_t vaddr)`**\n\n  `page_translate`函数可以根据下图来实现\n\n   ![](https://s2.loli.net/2022/01/14/WEHG64AdF8vrQc2.jpg)\n\n  为了展示更详细一点，这里提供一个简单的实现代码\n\n   ```c\n    uint32_t page_translate(uint32_t* pdir,uint32_t vaddr){\n        /*\n            simple version of page_translate\n            @pdir :page directory\n            @vaddr:virtual address\n        */\n        uint32_t pdx = (vaddr>>22)&0x3ff;\n        uint32_t ptx = (vaddr>>12)&0x3ff;\n        uint32_t off = vaddr&0xfff;\n        uint32_t pde = pdir[pdx];\n        assert(pde&0x1);//assert the pde is valid\n        uint32_t* ptab = (pde&~0x3ff)<<2;\n        uint32_t pte = ptab[ptx];\n        assert(pte&0x1);//assert the pte is valid\n        uint32_t paddr = ((pte&~0x3ff)<<2)|off;\n        return  paddr;\n    }\n   ```\n\n2. **`uint32_t isa_vaddr_read(vaddr_t addr, int len)`**\n\n   如果`satp.MODE`为1，则为开启分页，此时要判断是否跨页，如果跨页则分别读取并凭借，否则直接通过`page_tranlsate`转换为物理地址进行读取。如果`stap.MODE`为0，则直接当做物理地址进行读取。\n\n3. **`void isa_vaddr_write(vaddr_t addr, uint32_t data, int len)`**\n\n   同理\n\n#### 4.2.4.进程切换\n\n对于不同进程切换的情况，页目录基地址也会随之改变，因此需要跟随进程切换一同切换`satp`,在陷入后，立即将当前页目录基地址放入上下文进行保存。在操作执行完之后，立即更新当前的`satp`，因为进程切换了，所以`satp`要跟着切换\n\n```mermaid\ngraph LR \nA[_yield]\nB[__am_asm_trap]\nC[__am_irq_handle]\nD[__get_cur_as]\nE[__am_switch]\n\nsubgraph nexus-am\n\tsubgraph am/src/riscv32/nemu\n\t\tsubgraph trap.S\n\t\t\tB\n\t\tend\n\t\tsubgraph cte.c\n\t\t\tA-->B\n\t\t\tB-->C\n\t\tend\n\t\tsubgraph vme.c\n\t\t\tC-->D\n\t\t\tC-->E\n\t\tend\n\tend\nend\nstyle nexus-am fill: cornflowerblue\n```\n\n1. **`_Context* __am_irq_handle(_Context *c)`**\n\n   在开头调用`__get_cur_as`将当前的页目录基地址存储入当前的上下文。在结束时调用`__am_switch`将新的页目录基地址更新到`satp`中。\n\n### 4.3.中断\n\n终端主要分为三个流程。其一是时钟，时钟每次被唤起都会将`cpu.INTR`置1。其二，`cpu`每次执行一次`exec_once`便会调用`isa_query_intr`判断是否需要中断，如果是则调用`raise_intr`进行自陷，来进行中断处理。因为我们不想在处理中断时被中断，因此在进入自陷前关掉中断并保存中断状态`sstatus.PIE`到`sstatus.SIE`，在出`sret`最后一步再进行恢复。其三，在进入自陷处理函数`__am_irq_handle`时需要判断自陷诱发原因是否是时钟中断，如果是则需要传递信息给事件处理函数`do_event`\n\n![](https://s2.loli.net/2022/01/14/kw1d9YTRxKv7JZt.jpg)\n\n```mermaid\ngraph LR \nA[\"make_EHelper(ecall)\"]\nB[\"make_EHelper(sret)\"]\nC[raise_intr]\nD[isa_query_intr]\nE[exec_once]\nc[timer_intr]\nd[dev_raise_intr]\nd-.-D\nsubgraph nemu\n\tsubgraph cpu\n\t\tsubgraph cpu.c\n\t\t\tE\n\t\tend\n\tend\n\tsubgraph device\n\t\tsubgraph timer.c\n\t\t\tc\t\n\t\tend\n\t\tsubgraph _intr.c\n\t\t\tc-->d\n\t\tend\n\tend\n\tsubgraph isa/riscv32\n        subgraph exec\n            subgraph system.c\n                A\n                B\n            end\n         end\n        subgraph intr.c\n        \tA-->C\n        \tE-->D\n        \tD-->C\n        end\n\tend\nend\ng[do_event]\nC-.-e\nsubgraph nexus-am\n\tsubgraph irq.c\n\t\tg\n\tend\nend\ne[__am_asm_trap]\nf[__am_irq_handle]\nsubgraph nanos-lite\n\tsubgraph trap.S\n\t\te\n\tend\n\tsubgraph cte.c\n\t\te-->f\n\t\tf-->g\n\tend\nend\nstyle nemu fill:DarkGray \nstyle nanos-lite fill: coral\nstyle nexus-am fill: cornflowerblue\n```\n\n由于时间原因，这个阶段虽然代码已经实现，但是还是有bug。\n\n****\n## 5.PA5 PAL pro\n\n### 5.1.浮点数\n\n实现`navy-app/apps/pal/include/FLOAT.h`和`navy-apps/apps/src/FLOAT/FLOAT.c`就可以了\n\n```c\n//navy-app/apps/pal/include/FLOAT.h\nstatic inline int F2int(FLOAT a) {return (a &= 0xffff0000)>>16;}\nstatic inline FLOAT int2F(int a) {return a << 16;}\nstatic inline FLOAT F_mul_int(FLOAT a, int b) {return a * b;}\nstatic inline FLOAT F_div_int(FLOAT a, int b) {return a / b;}\n```\n\n```c\n//navy-apps/apps/src/FLOAT/FLOAT.c\nFLOAT F_mul_F(FLOAT a, FLOAT b) {\n\tlong long c = (long long)a * (long long)b;\n\treturn (FLOAT)(c >> 16);\n}\n\nFLOAT F_div_F(FLOAT a, FLOAT b) {\n\tFLOAT p, q;\n\tasm volatile(\"idiv %2\" : \"=a\"(p), \"=d\"(q) : \"r\"(b), \"a\"(a << 16), \"d\"(a >> 16));\n\treturn p;\n}\n\nFLOAT f2F(float a) {\n\tint b = *(int *)&a;\n\tint sign = b >> 31;\n\tint exp = (b >> 23) & 0xff;\n\tFLOAT c = b & 0x7fffff;\n\tif (exp != 0) {\n\t\tc += 1 << 23;\n\t}\n\texp -= 150;\n\tif (exp < -16) {\n\t\tc >>= -16 - exp;\n\t}\n\tif (exp > -16) {\n\t\tc <<= exp + 16;\n\t}\n\treturn sign == 0 ? c : -c;\n}\n\nFLOAT Fabs(FLOAT a) {\n\tFLOAT b;\n\tif (a > 0){\n\t\tb = a;\n\t} else {\n\t\tb = -a;\n\t}\n\treturn b;\n}\n```\n\n### 5.2.JIT\n\n这让:older_man:怎么实现啊:sweat_smile:，看看得了，感觉龙芯说用LoongArch跑x86也是跟这个一样，做汇编级别的翻译。\n\n****\n\n","frontmatter":{"date":"2022-01-09","description":"华中科技大学计算机学院系统训练","title":"[HUST]PA","bg":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAMBAgQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAeW/DZiRIV//xAAZEAADAQEBAAAAAAAAAAAAAAAAAQIRAzH/2gAIAQEAAQUC55rqalk+0az/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAACAwAAAAAAAAAAAAAAAAAAICExYf/aAAgBAQAGPwKTSk//xAAaEAADAQEBAQAAAAAAAAAAAAAAAREhMVFh/9oACAEBAAE/IWVawQc9QmrXDiM08yH0P//aAAwDAQACAAMAAAAQOy//xAAXEQADAQAAAAAAAAAAAAAAAAAAASER/9oACAEDAQE/EMolD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEBAQEBAQAAAAAAAAAAAAERACExUZH/2gAIAQEAAT8QVyIape6fSng8kx5Po7nTYiyJcqH6BDLev93/2Q==","aspectRatio":1.834862385321101,"src":"/static/205a3f749fcfd78769fa811b23a8ac52/14b42/in_pain.jpg","srcSet":"/static/205a3f749fcfd78769fa811b23a8ac52/f836f/in_pain.jpg 200w,\n/static/205a3f749fcfd78769fa811b23a8ac52/2244e/in_pain.jpg 400w,\n/static/205a3f749fcfd78769fa811b23a8ac52/14b42/in_pain.jpg 800w,\n/static/205a3f749fcfd78769fa811b23a8ac52/47498/in_pain.jpg 1200w,\n/static/205a3f749fcfd78769fa811b23a8ac52/0e329/in_pain.jpg 1600w,\n/static/205a3f749fcfd78769fa811b23a8ac52/a41d1/in_pain.jpg 2000w","sizes":"(max-width: 800px) 100vw, 800px"}}}}},"defaultImg":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDAv/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHateUxEv/EABoQAAIDAQEAAAAAAAAAAAAAAAECAAMREhP/2gAIAQEAAQUCdYgxg9YCg2DjR4pP/8QAFhEBAQEAAAAAAAAAAAAAAAAAABES/9oACAEDAQE/Aco//8QAFhEBAQEAAAAAAAAAAAAAAAAAABMB/9oACAECAQE/AaYq/8QAGxAAAgEFAAAAAAAAAAAAAAAAAAEyESEiMUH/2gAIAQEABj8CRm7EkSKcNH//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAhMWFxkbH/2gAIAQEAAT8hxgm6Ea8B+QVHbAhkA3UNudmMxGROzP/aAAwDAQACAAMAAAAQ8C//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxAj/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAgEBPxBqwg//xAAbEAEBAQEAAwEAAAAAAAAAAAABESEAMVGBYf/aAAgBAQABPxCdlMOWeYdckOKwFN+jfnWTzNDOaskA0T94QtGgFft4zI+ivf/Z","aspectRatio":1.6,"src":"/static/626eca6df3146e4daf0b83c44fe7548e/14b42/6.jpg","srcSet":"/static/626eca6df3146e4daf0b83c44fe7548e/f836f/6.jpg 200w,\n/static/626eca6df3146e4daf0b83c44fe7548e/2244e/6.jpg 400w,\n/static/626eca6df3146e4daf0b83c44fe7548e/14b42/6.jpg 800w,\n/static/626eca6df3146e4daf0b83c44fe7548e/47498/6.jpg 1200w,\n/static/626eca6df3146e4daf0b83c44fe7548e/a6974/6.jpg 1536w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"pageContext":{"fileAbsolutePath":"D:/Project/HomePage/chi-s-page-0/static/blog/Engineering/Computer/Composition/hust_pa.md"}},
    "staticQueryHashes": []}