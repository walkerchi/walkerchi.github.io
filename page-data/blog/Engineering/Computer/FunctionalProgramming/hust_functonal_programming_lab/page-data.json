{
    "componentChunkName": "component---src-templates-blog-template-blog-template-jsx",
    "path": "/blog/Engineering/Computer/FunctionalProgramming/hust_functonal_programming_lab",
    "result": {"data":{"markdownRemark":{"rawMarkdownBody":"\r\n\r\n\r\n# Lab1\r\n\r\n## Q1\r\n\r\n 下列模式能否与类型为int list的L匹配成功？如果匹配不成功，指出该模式的类型？（假设x为int类型）\r\n\r\nx::L\t    *成功*\t\r\n\\_::\\_\t\t*成功*\r\nx::(y::L)  *y为int时成功*\r\n(x::y)::L  *语法错误*\r\n[x, y]      *y为int时成功*\r\n\r\n## Q2\r\n\r\n试写出与下列表述相对应的模式。如果没有模式与其对应，试说明原因\r\n\r\nlist of length 3           \t\t\t\t\t\r\nlists of length 2 or 3\r\nNon-empty lists of pairs\r\nPairs with both components being non-empty lists\r\n\r\n## Q3\r\n\r\n分析下述程序段（左边括号内为标注的行号）\r\n\r\n```sml\r\nval x : int = 3\r\n \t\tval temp : int = x + 1\r\n \t\tfun assemble (x : int, y : real) : int =\r\n\t\t\tlet val g : real = let val x : int = 2\r\n\t\t\t\t\t\t\tval m : real = 6.2 * (real x)\r\n\t\t\t\t\t\t\tval x : int = 9001\r\n \t\t\t\t\t\t\tval y : real = m * y\r\n\t\t\t\t\t\t  in y – m\r\n \t\t\t\t\t\t  end\r\n\t\t\tin\r\n\t\t\t  x + (trunc g)\r\n\t\t\tend\r\nval z = assemble (x, 3.0)\r\n\r\n```\r\n\r\n试问：第4行中的x、第5行中的m和第6行中的x的声明绑定的类型和值分别为什么？第14行表达式assemble(x, 3.0)计算的结果是什么？\r\n\r\n*4.x:int = 2*\r\n\r\n*5.m:real = 12.4*\r\n\r\n*6.x:int = 9001*\r\n\r\n*14.z:int = 27*\r\n\r\n\r\n\r\n## Q4\r\n\r\n指出下列代码的错误\r\n\r\n- ```\r\n  (* pi: real *)\r\n   val pi : real = 3.14159;\r\n  ```\r\n\r\n\r\n  *正确*\r\n\r\n- ```\r\n  (* fact: int -> int *)\r\n  fun fact (0 : int) : int = 1\r\n    | fact n = n * (fact (n - 1));\r\n  ```\r\n\r\n  *正确*\r\n\r\n  \r\n\r\n- ```\r\n  (* f : int -> int *)\r\n  fun f (3 : int) : int = 9\r\n      f _ = 4;\r\n  ```\r\n\r\n  *修正*\r\n\r\n  ```\r\n  fun f(3:int):int = 9\r\n  \r\n    | f _ = 4;\r\n  ```\r\n\r\n- ```\r\n  (* circ : real -> real *)\r\n   fun circ (r : real) : real = 2 * pi * r\r\n  ```\r\n\r\n     *修正*\r\n\r\n   ```\r\n  fun circ(r:real):real = 2.0 * pi * r\r\n   ```\r\n\r\n- ```\r\n  (* semicirc : real -> real *)\r\n  fun semicirc : real = pie * r\r\n  ```\r\n\r\n  *修正*\r\n\r\n  ```\r\n   fun semicirc (r:real):real = pi*r\r\n  ```\r\n\r\n\r\n- ```\r\n  (* area : real -> real *)\r\n   fun area (r : int) : real = pi * r * r\r\n  ```\r\n\r\n  *修正*\r\n\r\n  ```\r\n  fun area (r:int):real = pi * real r * real r\r\n  ```\r\n\r\n  \r\n\r\n## Q5\r\n\r\n在提示符下依次输入下列语句，观察并分析每次语句的执行结果。\r\n\r\n\r\n- ``` \r\n  3+ 4;\r\n  ```\r\n\r\n  ```\r\n  val it = 7 : int\r\n  ```\r\n\r\n- ```\r\n  3 + 2.0;\r\n  ```\r\n\r\n  ```\r\n  stdIn:21.1-21.6 Error: operator and operand do not agree [overload - bad instantiation]\r\n  operator domain: 'Z[INT] * 'Z[INT]\r\n  operand:         'Z[INT] * real\r\n  in expression:\r\n    3 + 2.0\r\n  ```\r\n\r\n - ```\r\n   it + 6;\r\n   ```\r\n\r\n   缺省变量it 使用3+4的结果\r\n\r\n   ```\r\n   val it = 13 : int\r\n   ```\r\n\r\n- ```\r\n  val it = “hello”;\r\n  ```\r\n\r\n  ```\r\n  val it = \"hello\" : string\r\n  ```\r\n\r\n- ```\r\n  it + “ world”;\r\n  ```\r\n\r\n  ```\r\n  stdIn:23.4 Error: overloaded variable not defined at type\r\n  symbol: +\r\n  type: string\r\n  ```\r\n\r\n- ```\r\n  it + 5;\r\n  ```\r\n\r\n  ```\r\n  stdIn:25.1-25.6 Error: operator and operand do not agree [overload - bad instantiation]\r\n  operator domain: string * string\r\n  operand:         string * 'Z[INT]\r\n  in expression:\r\n    it + 5\r\n  stdIn:25.4 Error: overloaded variable not defined at type\r\n  symbol: +\r\n  type: string\r\n  ```\r\n\r\n- ```\r\n  val a = 5;\r\n  ```\r\n\r\n  ```\r\n  val a = 5 : int\r\n  ```\r\n\r\n- ```\r\n  a = 6;\r\n  ```\r\n\r\n  ```\r\n  val it = false : bool\r\n  ```\r\n\r\n- ```\r\n  a + 8; \r\n  ```\r\n\r\n  ```\r\n  val it = 13 : int\r\n  ```\r\n\r\n- ```\r\n  val twice = (fn x => 2 * x);\r\n  ```\r\n\r\n  匿名函数，类似JS的匿名函数和python和c++的lambda函数\r\n\r\n  ```\r\n  val twice = fn : int -> int\r\n  ```\r\n\r\n- ```\r\n  twice a;\r\n  ```\r\n\r\n  ```\r\n  val it = 10 : int\r\n  ```\r\n\r\n- ```\r\n  let x = 1 in x end;\r\n  ```\r\n\r\n  ?????\r\n\r\n  ```\r\n  stdIn:1.2-37.2 Error: syntax error: deleting  LET IDA EQUALOP\r\n  \r\n  stdIn:42.1 Error: syntax error found at IN\r\n  ```\r\n\r\n- ```\r\n  foo;\r\n  ```\r\n\r\n  ```\r\n  stdIn:1.2-35.2 Error: unbound variable or constructor: foo\r\n  ```\r\n\r\n- ```\r\n  [1, “foo”];\r\n  ```\r\n\r\n  ```\r\n  stdIn:1.2-42.3 Error: operator and operand do not agree [overload - bad instantiation]\r\n  operator domain: 'Z[INT] * 'Z[INT] list\r\n  operand:         'Z[INT] * string list\r\n  in expression:\r\n   1 :: \"foo\" :: nil\r\n  ```\r\n\r\n\r\n\r\n\r\n\r\n## Q6\r\n\r\n函数sum用于求解整数列表中所有整数的和，函数定义如下\r\n\r\n```\r\n(* sum : int list -> int \t\t*)\r\n(* REQUIRES: true\t\t*)\r\n(* ENSURES: sum(L) evaluates to the sum of the integers in L. *)\r\nfun sum [ ] = 0\r\n    | sum (x ::L) = x + (sum L);\r\n```\r\n\r\n\r\n完成函数mult的编写，实现求解整数列表中所有整数的乘积。\r\n\r\n```\r\n(* mult : int list -> int \t\t*)\r\n(* REQUIRES: true\t\t*)\r\n(* ENSURES: mult(L) evaluates to the product of the integers in L. *)\r\nfun mult [ ] = \t\t(* FILL IN *)\r\n    | mult (x ::L) = \t(* FILL IN *) \r\n\r\n```\r\n\r\n```\r\nfun mult [] = 0\r\n  | mult (x::L) = x*mult L;\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# Lab2\r\n\r\n## Q1\r\n\r\n 分析以下函数或表达式的类型(先自己分析再程序验证)\r\n\r\n- ```\r\n  fun all (your, base) =\r\n    case your of·\r\n    0 => base\r\n    | _ => \"are belong to us\" :: all(your - 1, base)\r\n  ```\r\n\r\n  类型\r\n\r\n  ```\r\n  val int* string list->string list\r\n  ```\r\n\r\n\r\n- ```\r\n  fun funny (f, []) = 0\r\n  | funny (f, x::xs) = f(x, funny(f, xs))\r\n  ```\r\n\r\n  类型\r\n\r\n  ```\r\n  val ('a*int->int) * 'a list -> int\r\n  ```\r\n\r\n\r\n- ```\r\n  (fn x => (fn y => x)) \"Hello, World!\"\r\n  ```\r\n\r\n  ```\r\n  val it = fn : ?.X1 -> string\r\n  ```\r\n\r\n\r\n## Q2\r\n\r\n用归纳法证明ins函数和isort函数的正确性\r\n\r\n```\r\nfun ins (x, [ ]) = [x]\r\n| ins (x, y::L) = case compare(x, y) of\r\n\t\t    GREATER => y::ins(x, L)\r\n\t  |        _ \t  => x::y::L\r\n```\r\n\r\n*证明*\r\n当L长度为1时，[x]为有序\r\n假设L'长度为n-1有序，则对于L长度为n\r\n  min(x,y)::L'有序\r\n\r\n```\r\nisort : int list -> int list\r\n\r\n(* REQUIRES true \t\t\t\t*)\r\n(* ENSURES isort(L) = a sorted perm of L \t*)\r\n\r\nfun isort [ ] = [ ]\r\n   |   isort (x::L) = ins (x, isort L)\r\n```\r\n\r\n*证明*\r\n当L长度为0时,[]有序\r\n假设L'长度为n-1有序，则对于L长度为n\r\n\tL=ins(x,L')有序，所以L有序\r\n\r\n\r\n\r\n\r\n\r\n## Q3\r\n\r\n分析下面菲波拉契函数的执行性能\r\n\r\n```\r\nfun fib n = if n<=2 then 1 else fib(n-1) + fib(n-2);\r\n```\r\n\r\n树状结构\r\n$O(2^n)$\r\n\r\n```\r\nfun fibber (0: int) : int * int = (1, 1)\r\n  | fibber (n: int) : int * int =\r\n   let val (x: int, y: int) = fibber (n-1)\r\n   in (y, x + y)\r\n   end\r\n```\r\n\r\n线性结构\r\n$O(n)$\r\n\r\n## Q4\r\n\r\n定义函数divisibleByThree: int -> bool，以使当n为3的倍数时，divisibleByThree n为true，否则为false。注意：程序中不能使用取余函数’mod’。\r\n\r\n```\r\n(* divisibleByThree : int -> bool \t*)\r\n(* REQUIRES: n>=0\t\t\t\t*)\r\n(* ENSURES: divisibleByThree n evaluates to true if n is a multiple of 3 and to false otherwise *)\r\nfun divisibleByThree 0=true\r\n  | divisibleByThree 1=false\r\n  | divisibleByThree 2=false\r\n  | divisibleByThree n=divisbleByThree(n-3);\r\n```\r\n\r\n\r\n## Q5\r\n\r\n函数evenP为偶数判断函数，即当且仅当该数为偶数时返回true。\r\n    其代码描述如下：\r\n\r\n```\r\n(* evenP : int -> bool \t\t*)\r\n\t(* REQUIRES: n >= 0 \t\t*)\r\n\t(* ENSURES: evenP n evaluates to true iff n is even. *)\r\n\tfun evenP (0 : int) : bool = true\r\n  \t    | evenP 1 = false\r\n  \t    | evenP n = evenP (n - 2)\r\n```\r\n\r\n试编写奇数判断函数oddP: int -> bool，当且仅当该数为奇数时返回true。注意：代码不要调用函数evenP或mod。\r\n\r\n\r\n```\r\nfun oddP (0: int):bool = false\r\n |  oddP 1 = true\r\n | oddP n = oddP(n-2);\r\n```\r\n\r\n\r\n## Q6\r\n\r\n编写函数 interleave: int list * int list -> int list，该函数能实现两个int list数据的合并，且两个list中的元素在结果中交替出现，直至其中一个int list数据结束，而另一个int list数据中的剩余元素则直接附加至结果数据的尾部。如：\r\ninterleave([2],[4]) = [2,4]\r\ninterleave([2,3],[4,5]) = [2,4,3,5]\r\ninterleave([2,3],[4,5,6,7,8,9]) = [2,4,3,5,6,7,8,9]\r\ninterleave([2,3],[ ]) = [2,3]\r\n\r\n```\r\nfun interleave ([]:int list, []:int list):int list = []\r\n| interleave ([]:int list, y:int list):int list=y\r\n| interleave (x:int list, []:int list):int list=x\r\n| interleave (x::X:int list, y::Y:int list):int list = x::(y::interleave(X, Y))\r\n```\r\n\r\n\r\n## Q7\r\n\r\n编写函数reverse和reverse’，要求：\r\n函数类型均为：int list->int list，功能均为实现输出表参数的逆序输出；\r\n函数reverse不能借助任何帮助函数；函数reverse’可以借助帮助函数，时间复杂度为O(n)。\r\n\r\n```\r\nfun reverse []:int list :int list= []\r\n| reverse x::X:int list :int list= (reverse X)@[x]; \r\n\r\n\r\nfun helper ([]:int list, y:int list):int list = y\r\n| helper (x::L:int list, y:int list) = helper(L, x::y);\r\n\r\nfun reverse' (x: int list):int list = helper(x, []);\r\n```\r\n\r\n\r\n\r\n## Q8\r\n\r\n给定一个数组A[1..n]，前缀和数组PrefixSum[1..n]定义为：\tPrefixSum[i] = A[0]+A[1]+...+A[i-1]；\r\n例如：PrefixSum [ ] = [ ]\r\n\t  PrefixSum [5,4,2] = [5, 9, 11]\r\n\t  PrefixSum [5,6,7,8] = [5,11,18,26]\r\n\r\n试编写：\r\n函数PrefixSum: int list -> int list，\r\n\t要求：WPrefixSum(n) = O(n2)。(n为输入int list的长度)\r\n(2) 函数fastPrefixSum: int list -> int list，\r\n\t要求： WfastPrefixSum(n) =O(n). \r\n\t\t（提示：可借助帮助函数PrefixSumHelp）\r\n\t\r\n\r\n```\r\nfun helper1 ([]:int list):int = 0\r\n| helper1((x::X):int list):int= x+(helper1(X));\r\n\r\nfun helper2 (prefix:int list, []):int list = []\r\n| helper2 (prefix:int list, (x::tail):int list):int list= helper1(prefix@[x])::helper2(prefix@[x], tail);\r\n\r\nfun PrefixSum (x:int list):int list = helper2([],x);\r\n```\r\n\r\n```\r\nfun helper3(x:int, []:int list):int list = []\r\n| helper3(x:int , (y::tail):int list):int list= (x+y)::helper3(x+y, tail);\r\n\r\nfun fastPrefixSum(x:int list):int list = helper3(0, x);\r\n```\r\n\r\n\r\n\r\n# Lab3\r\n\r\n## Q1\r\n\r\n编写函数listToTree: int list -> tree，将一个表转换成一棵平衡树\r\n\r\n提示：可调用split函数，split函数定义如下：\r\n如果L非空，则存在L1, x, L2，满足：\r\n\tsplit L = (L1, x, L2) \t且 \r\n\tL = L1 @ x :: L2 \t\t且 \r\n\tlength(L1)和length(L2)差值小于1。\r\n\r\n```\r\ndatatype tree = Empty | Node of tree*int*tree;\r\n\r\nfun split (x:int list):(int list*int*int list) = \r\n\tlet \r\n\t\tval ind = (List.length(x) div 2)\r\n\t\tval y::R = List.drop(x,ind)\r\n\t\tval L    = List.take(x,ind)\r\n\tin\r\n\t\t(L,y,R)\r\n\tend;\r\n\t\r\nfun listToTree ([]:int list):tree = Empty\r\n  | listToTree ([x]:int list):tree = Node(Empty,x,Empty)\r\n  | listToTree (X:int list):tree = \r\n  \t\tlet \r\n  \t\t\tval (L,x,R) = split(X)\r\n  \t\tin \r\n  \t\t\tNode(listToTree(L),x,listToTree(R))\r\n  \t\tend;\r\n\r\n  \t\t\t\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Q2\r\n\r\n编写函数revT: tree -> tree，对树进行反转，使trav(revT t) = reverse(trav t)。（trav为树的中序遍历函数）。假设输入参数为一棵平衡二叉树，验证程序的正确性，并分析该函数的执行性能（work和span）\r\n\r\n$Span_{revT} = O(d)$\r\n\r\n$Work_{revT} = O(n)$\r\n\r\n``` \r\ndatatype tree = Empty | Node of tree*int*tree;\r\n\r\nfun trav (Empty:tree):int list = []\r\n  | trav (Node(l,x,r):tree):int list = \r\n  \t\tlet \r\n  \t\t\tval L = trav l\r\n\t\t\tval R = trav r\r\n\t\tin \r\n\t\t\tL@[x]@R\r\n\t\tend;\r\n\t\t\r\n\r\nfun revT (Empty:tree):tree = Empty\r\n  | revT (Node(l,x,r):tree):tree = Node(revT r, x, revT l);\r\n  \r\n\r\n\r\nfun reverse (x:int list):int list = List.rev(x);\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Q3\r\n\r\n编写函数binarySearch: tree * int -> bool。当输出参数1为有序树时，如果树中包含值为参数2的节点，则返回true；否则返回false。要求：程序中请使用函数Int.compare（系统提供），不要使用<, =, >。\r\ndatatype order = GREATER | EQUAL | LESS\r\ncase Int.compare(x1, x2) of\r\n\tGREATER => (* x1 > x2 *)\r\n        | EQUAL => (* x1 = x2 *)\r\n        | LESS => (* x1 < x2 *)\r\n\r\n```\r\ndatatype tree = Empty | Node of tree*int*tree;\r\ndatatype order = GREATER | EQUAL | LESS\r\n\r\nfun binarySearch (Empty:tree,y:int):bool = false\r\n  | binarySearch (Node(Empty,x,Empty):tree,y:int):bool = (x=y)\r\n  | binarySearch (Node(l,x,r):tree,y:int):bool = \r\n  \t\tcase Int.compare(x,y) of\r\n  \t\t\tGREATER => binarySearch(l,y)\r\n  \t\t\t| EQUAL => true\r\n  \t\t\t| LESS  => binarySearch(r,y);\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Q4\r\n\r\n一棵minheap树定义为：\r\n\r\n1. t is Empty;\r\n2. t is a Node(L, x, R), where R, L are minheaps and values(L), value(R) >= x\t(value(T)函数用于获取树T的根节点的值）\r\n\r\n编写函数treecompare, SwapDown 和heapify：\r\n\r\n```\r\ntreecompare: tree * tree -> order (* when given two trees, returns a value of type order, based on which tree has a larger value at the root node *) \r\n\r\nSwapDown: tree -> tree (* REQUIRES the subtrees of t are both minheaps * ENSURES swapDown(t) = if t is Empty or all of t’s immediate children are empty then * just return t, otherwise returns a minheap which contains exactly the elements in t. *) \r\n\r\nheapify : tree -> tree (* given an arbitrary tree t, evaluates to a minheap with exactly the elements of t.  *)\r\n```\r\n\r\n分析SwapDown 和heapify两个函数的work和span\r\n\r\n$Span_{SwapDown}=O(d)$\r\n\r\n$Work_{SwapDown}=O(d)$\r\n\r\n$Span_{heapify}=O(d^2)$\r\n\r\n$Work_{heapify}=O(nlogn)$\r\n\r\n````\r\ndatatype tree = Empty | Node of tree*int*tree;\r\ndatatype order = GREATER | EQUAL | LESS\r\n\r\nfun treecompare (Empty, Empty) = EQUAL\r\n  | treecompare (X, Empty) = GREATER\r\n  | treecompare (Empty, Y) = LESS\r\n  | treecompare (Node(l1,x1,r1),Node(l2,x2,r2)) = Int.compare(x1,x2);\r\n  \t\t\t\r\nfun SwapDown (Empty:tree):tree = Empty\r\n  | SwapDown (Node(Empty,x,Empty):tree):tree = Node(Empty, x, Empty)\r\n  | SwapDown (Node(Empty,x,r):tree):tree = \r\n        let  \r\n            val Node(rl, rx, rr) = SwapDown r \r\n        in \r\n            case Int.compare(rx, x) of\r\n                LESS => Node(Empty, rx, Node(rl, x, rr))\r\n                | _  => Node(Empty, x,  Node(rl, rx,rr))\r\n        end\r\n  | SwapDown (Node(l,x,Empty):tree):tree = \r\n        let \r\n            val Node(ll,lx,lr) = SwapDown l \r\n        in\r\n            case Int.compare(lx, x) of\r\n                LESS => Node(Node(ll,x,lr), lx, Empty)\r\n                | _  => Node(Node(ll,lx,lr),x , Empty)\r\n        end\r\n  | SwapDown (Node(l,x,r):tree):tree = \r\n  \t\tlet \r\n  \t\t\tval Node(ll, lx, lr) = SwapDown l\r\n  \t\t\tval Node(rl, rx, rr) = SwapDown r\r\n  \t\tin\r\n  \t\t\tcase Int.compare(lx, rx) of\r\n  \t\t\t\tGREATER => (case Int.compare(rx, x) of\r\n                \t\t\tLESS => Node(Node(ll,lx,lr),rx,Node(rl,x,rr))\r\n                        \t| _ => Node(Node(ll,lx,lr),x,Node(rl,rx,rr))\r\n                            )\r\n                | LESS  => (case Int.compare(lx, x) of\r\n                 \t\t\tLESS => Node(Node(ll,x,lr),lx,Node(rl,rx,rr))\r\n                 \t\t\t| _  => Node(Node(ll,lx,lr),x,Node(rl,rx,rr))\r\n                            )\r\n                | EQUAL => Node(Node(ll,lx,lr),x,Node(rl,rx,rr)) \r\n         end;    \r\n         \r\n fun balance (T:tree):tree = listToTree(trav T);\r\n         \r\n fun heapify_helper(Empty:tree):tree = Empty\r\n   | heapify_helper(T:tree):tree = \r\n   \t\tlet \r\n            val Node(sd_l, sd_x, sd_r) = SwapDown T\r\n   \t\tin\r\n   \t\t\tNode( SwapDown sd_l, sd_x, SwapDown sd_r )\r\n   \t\tend\r\n         \r\n fun heapify (T:tree):tree = heapify_helper(balance T);\r\n````\r\n\r\n\r\n\r\n\r\n\r\n# Lab4\r\n\r\n## Q1\r\n\r\n编写函数thenAddOne，要求：\r\n1.函数类型为: ((int ->int) * int) -> int；\r\n2.功能为将一个整数通过函数变换(如翻倍、求平方或求阶乘)后再加1。\r\n\r\n```\r\nfun double(x) = 2*x;\r\nfun square(x) = x*x;\r\nfun factorial(1) = 1  \r\n  | factorial(x) = x*factorial(x-1);\r\n\r\nfun thenAddOne (f:(int->int),x:int):int = f(x)+1;\r\n```\r\n\r\n\r\n\r\n## Q2\r\n\r\n编写函数mapList，要求：\r\n1.类型为: ((‘a -> ‘b) * ‘a list) -> ‘b list；\r\n2.功能为实现整数集的数学变换(如翻倍、求平方或求阶乘)\r\n\r\n````\r\nfun mapList(f,[]) = []\r\n  | mapList(f,x::L) = f(x)::mapList(f,L);\r\n````\r\n\r\n\r\n\r\n\r\n\r\n## Q3\r\n\r\n编写函数mapList’，要求：\r\n\r\n  ① 函数类型为: (‘a -> ‘b) -> (‘a list -> ‘b list)；\r\n\r\n ② 功能为实现整数集的数学变换(如翻倍、求平方或求阶乘)。\r\n\r\n  ③ 比较函数mapList’和mapList，分析、体会它们有什么不同。\r\n\r\n````\r\nfun mapList' (f) = \r\n\tlet\r\n\t\tfun ret [] = []\r\n\t\t  | ret (x::L) = f(x)::ret(L)\r\n\tin\r\n\t\tret\r\n\tend;\r\n````\r\n\r\n\r\n\r\n\r\n\r\n## Q4\r\n\r\n编写函数：\r\n\texists: (‘a -> bool) -> ‘a list -> bool\r\n\tforall: (‘a -> bool) -> ‘a list -> bool\r\n   对函数p: t -> bool, 整数集L: t list,\r\n\t有：exist p L =>* true if there is an x in L such that p x=true;\r\n\t         exits p L =>* false otherwise.\r\n\t         forall p L =>* true if p x = true for every item x in L;\r\n\t         forall p L =>* false otherwise.\r\n\r\n```\r\nfun exists (f) = \r\n\tlet\r\n\t\tfun wrapper([]) = false\r\n           | wrapper(x::L)=\r\n           \t\tcase f(x) of\r\n           \t\t\ttrue => true\r\n           \t\t\t| false => wrapper(L) \r\n\tin\r\n\t\twrapper\r\n\tend;\r\n\t\r\n\t\r\nfun forAll (f) = \r\n\tlet \r\n\t\tfun wrapper([]) = true\r\n\t\t  | wrapper(x::L) = \r\n\t\t  \t\tcase f(x) of\r\n\t\t  \t\t\tfalse => false\r\n\t\t  \t\t\t| true => wrapper(L)\r\n\tin \r\n\t\twrapper\r\n\tend;\r\n\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Q5\r\n\r\n编写函数：\r\n\ttreeFilter: (‘a -> bool) -> ‘a tree -> ‘a option tree\r\n    将树中满足条件P（ ‘a -> bool ）的节点封装成option类型保留，否则替换成NONE\r\n\r\n```\r\ndatatype 'a tree = EMPTY | Node of 'a tree*'a*'a tree\r\ndatatype 'a option = NONE | SOME of 'a\r\n\r\nfun treeFilter (f) = \r\n\tlet\r\n\t\tfun wrapper(EMPTY) = EMPTY\r\n\t\t  | wrapper(Node(l,x,r)) = \r\n\t\t\tcase f(x) of \r\n\t\t\t\ttrue => Node(wrapper(l), SOME x, wrapper(r))\r\n\t\t\t\t| false => Node(wrapper(l), NONE, wrapper(r))\r\n\tin \r\n\t\twrapper\r\n\tend;\r\n```\r\n\r\n\r\n\r\n## Q6\r\n\r\n十进制数可表示为$54_{10}$，而二进制数可表示为$10_{2}$. 其中右下标的’10’,’2’称为基数。通常，给定一个基数b和n个数字dndn-1…d1组成的字符串，该数字字符串的值可用公式计算：∑i=1nbi-1di. 如：$54_{10}=5*10^1+4*10^0=54$,$10_2=1*2^1+0*2^0=2. $\r\n同时，任意一个数可以表示成b以内数字的int list形式。如11002=[0,0,1,1], 5410=[4,5].\r\n\r\n(1)编写高阶函数：toInt: int -> int list -> int.\r\n    对所有b>1和所有L: int list,如果L是一个b进制数的int list表示，函数toInt b L为其相应的整数值，toInt b的结果类型为：int list -> int.\r\n    如： val base2ToInt = toInt 2;\r\n              val 2 = base2ToInt [0,1];\r\n\r\n(2) 利用数学操作mod和div可以将任意十进制整数n表示成基于基数b的b进制数形式，如$42-_{10} = 132_{5}$。\r\n 编写高阶函数  toBase: int -> int -> int list 实现该转换：toBase b n将十进制数n转换为b进制数的int list表述形式（b>1, n≥0）。\r\n\r\n(3)编写高阶函数    convert: int * int -> int list -> int list\r\n对任意b1, b2 > 1和所有L: int list（L为一个b1进制数的int list表述形式），函数convert(b1, b2) L将b1进制数的int list表述L转换成b2进制数的int list表述，即满足 toInt b2 (convert(b1, b2) L) = toInt b1 L。\r\n\r\n\r\n\r\n### (1)\r\n\r\n```\r\nfun toInt(base) = \r\n\tlet\r\n\t\tfun wrapper ([]) = 0\r\n\t\t  | wrapper (x:L) = \r\n\t\t\tlet \r\n\t\t\t\tfun pow(0)=1\r\n\t\t\t\t  | pow(n) = base*pow(n-1)\r\n\t\t\t\tval pos = pow(List.length(L))\r\n\t\t\tin\r\n\t\t\t\tpos*x + wrapper(L)\r\n\t\t\tend\r\n\tin\r\n\t\twrapper\r\n\tend;\r\n```\r\n\r\n\r\n\r\n### (2)\r\n\r\n```\r\nfun toBase (base) = \r\n\tlet\r\n\t\tfun wrapper(0) = []\r\n\t\t  | wrapper(value) = \r\n\t\t  \tlet \r\n\t\t  \t\tval q = value div base\r\n\t\t  \t\tval p = value mod base\r\n\t\t  \tin\r\n\t\t  \t\twrapper(q)@[p]\r\n\t\t  \tend\r\n\tin\r\n\t\twrapper\r\n\tend;\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### (3)\r\n\r\n````\r\nfun convert (baseSrc, baseDst) = \r\n\tlet\r\n\t\tfun wrapper L = \r\n            let \r\n                val toIntSrc = toInt(baseSrc)\r\n                val toBaseDst = toBase(baseDst)\r\n            in\r\n                toBaseDst(toIntSrc(L))\r\n            end\r\n            \r\n\tin\r\n\t\twrapper\r\n\tend;\r\n\t\r\n\t\r\n\t\r\nfun convert (baseSrc, baseDst) = \r\n\tlet\r\n\t\tfun wrapper = toBase(baseDst, toInt(baseSrc))\r\n\tin\r\n\t\twrapper\r\n\tend;\r\n````\r\n\r\n","frontmatter":{"date":"2021-04-07","description":"华中科技大学计算机学院函数式编程实验笔记","title":"[HUST]函数式编程实验","bg":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,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","aspectRatio":0.704225352112676,"src":"/static/ee3776bb0b725b1360d2c8d20557307d/ee604/crossroad.png","srcSet":"/static/ee3776bb0b725b1360d2c8d20557307d/69585/crossroad.png 200w,\n/static/ee3776bb0b725b1360d2c8d20557307d/497c6/crossroad.png 400w,\n/static/ee3776bb0b725b1360d2c8d20557307d/ee604/crossroad.png 800w,\n/static/ee3776bb0b725b1360d2c8d20557307d/eab2a/crossroad.png 841w","sizes":"(max-width: 800px) 100vw, 800px"}}}}},"defaultImg":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDAv/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHateUxEv/EABoQAAIDAQEAAAAAAAAAAAAAAAECAAMREhP/2gAIAQEAAQUCdYgxg9YCg2DjR4pP/8QAFhEBAQEAAAAAAAAAAAAAAAAAABES/9oACAEDAQE/Aco//8QAFhEBAQEAAAAAAAAAAAAAAAAAABMB/9oACAECAQE/AaYq/8QAGxAAAgEFAAAAAAAAAAAAAAAAAAEyESEiMUH/2gAIAQEABj8CRm7EkSKcNH//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAhMWFxkbH/2gAIAQEAAT8hxgm6Ea8B+QVHbAhkA3UNudmMxGROzP/aAAwDAQACAAMAAAAQ8C//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxAj/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAgEBPxBqwg//xAAbEAEBAQEAAwEAAAAAAAAAAAABESEAMVGBYf/aAAgBAQABPxCdlMOWeYdckOKwFN+jfnWTzNDOaskA0T94QtGgFft4zI+ivf/Z","aspectRatio":1.6,"src":"/static/626eca6df3146e4daf0b83c44fe7548e/14b42/6.jpg","srcSet":"/static/626eca6df3146e4daf0b83c44fe7548e/f836f/6.jpg 200w,\n/static/626eca6df3146e4daf0b83c44fe7548e/2244e/6.jpg 400w,\n/static/626eca6df3146e4daf0b83c44fe7548e/14b42/6.jpg 800w,\n/static/626eca6df3146e4daf0b83c44fe7548e/47498/6.jpg 1200w,\n/static/626eca6df3146e4daf0b83c44fe7548e/a6974/6.jpg 1536w","sizes":"(max-width: 800px) 100vw, 800px"}}}},"pageContext":{"fileAbsolutePath":"D:/Project/HomePage/chi-s-page-0/static/blog/Engineering/Computer/FunctionalProgramming/hust_functonal_programming_lab.md"}},
    "staticQueryHashes": []}