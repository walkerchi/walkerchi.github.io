{"pageProps":{"frontmatter":{"title":"[RWTHAachen]Computer Vision 2","image":"https://s2.loli.net/2022/06/18/8XYy9qx5zKhnBmg.png","description":"Outline of Computer Vision 2 :)","author":"mingyuan chi","date":"2021-2-1"},"content":"<h1>Single-Object Tracking</h1><h2>Background modeling</h2><p>simple and fast</p><h3>Simple Background Models</h3><p>Assumption:</p><ul><li>camera is static</li><li>objects that move are important</li></ul><h4>Simple Background Subtraction</h4><div class=\"math math-display\">threshold(|I(t)-B|)</div><img src=\"https://s2.loli.net/2022/02/04/rNMtfiCAWsTYRqQ.png\" width=\"1901\" height=\"811\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABCAIAAAB2XpiaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFklEQVQImWO4evXCy9c3/v9/w8DAAAA/ZggRQkiYqAAAAABJRU5ErkJggg==\"><ol><li><p>ghost shadow, object's moving lead to two objects</p><img src=\"https://s2.loli.net/2022/02/04/jNmncxYe3X7gaO1.png\" height=\"583\" width=\"683\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMElEQVQImWP4///Jizentm2as2PLfIa62vK62rKM5LispHgGBgYGfX19KWlZRmZmAKmDD63tiDWlAAAAAElFTkSuQmCC\"></li><li><p>illumination changes</p><img src=\"https://s2.loli.net/2022/02/04/HzCQrSdJwykxhIj.png\" height=\"479\" width=\"715\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIElEQVQImWP4DwJ/t23bpq6uzmBpaVVQUGBgYMDAwAAAyF0LHEb7XzYAAAAASUVORK5CYII=\"></li><li><p>global threshold is often suboptimal</p><img src=\"https://s2.loli.net/2022/02/04/RlsK3CXUySPbhcv.png\" height=\"487\" width=\"717\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAI0lEQVQImWNob2sPDQ3l5+efNm0aAwMDg7a29rRp0/7//w8AazkJwwzWrHwAAAAASUVORK5CYII=\"></li></ol><h4>Simple Frame Differencing</h4><div class=\"math math-display\">threshold(|I(t)-B(t-1)|)</div><img src=\"https://s2.loli.net/2022/02/04/IKHSukRe8Btza5W.png\" width=\"1942\" height=\"998\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAI0lEQVQImWMoK89fv2HhpMn1DAwMDN+/fc/ODXv46M7///8BpNUOr4RPquYAAAAASUVORK5CYII=\"><p>Props:</p><ul><li>quick to adapt to change of lighting, camera motion</li></ul><p>Cons:</p><ul><li>only detect uniform color object</li><li>cannot detect an object moving toward or away from camera</li></ul><h4>Temporal Scale</h4><div class=\"math math-display\">D(N)=threshold(|I(t)-I(t+N)|)</div><h4>Three Frame Differencing</h4><div class=\"math math-display\">D(N)\\&#x26;D(-N)</div><h4>Adaptive Background Subtraction</h4><div class=\"math math-display\">threshold(|\\alpha I(t)+(1-\\alpha)B(t-1)|)</div><img src=\"https://s2.loli.net/2022/02/07/3YDz1FoPHajBWNG.png\" width=\"1194\" height=\"765\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAI0lEQVQImWOIT4iOivUtLU9nYGBk+PLlc0WN77171/7//w8AhFoNHp22YncAAAAASUVORK5CYII=\"><h3>Statistical Background Models</h3><h4>Single Gaussian</h4><div class=\"math math-display\">\\begin{aligned} \\hat{\\mu}&#x26;=\\frac{1}{N}\\sum^Nx_n\\\\ \\sigma^2 &#x26;= \\frac{1}{N-1}\\sum^N(x_n-\\hat\\mu)^2 \\end{aligned}</div><p><strong>online adaptation</strong></p><p>running estimation</p><div class=\"math math-display\">\\begin{aligned} \\hat\\mu^{t+1}&#x26;=\\hat\\mu^t+\\frac{1}{N}x^{t+1}-\\frac{1}{N}x^{t+1-T}\\\\ {\\hat\\sigma^2}^{t+1}&#x26;={\\hat\\sigma^2}^t+\\frac{1}{N-1}(x^{t+1}-\\hat\\mu^{t+1})^2-\\frac{1}{N-1}(x^{t+1-T}-\\hat\\mu^{t+1-T})^2 \\end{aligned}</div><p>exponential moving average filter</p><div class=\"math math-display\">\\begin{aligned} \\hat\\mu^{t+1}&#x26;=(1-\\alpha)\\hat\\mu^t+\\alpha x^{t+1}\\\\ {\\hat\\sigma^2}^{t+1}&#x26;=(1-\\alpha){\\hat\\mu^2}^t+ \\alpha (x^{t+1}-\\hat\\mu^{t+1})^2 \\end{aligned}</div><p>Cons:</p><ul><li>a single gaussian is insufficient</li><li>sensitivity</li></ul><h4>Mixture of Gaussian</h4><p><strong>Stauffer-Grimson Background Model</strong></p><p><span class=\"math math-inline\">M_{k,t}</span> : <span class=\"math math-inline\">M_{k,t}=1</span> iff <span class=\"math math-inline\">k</span> is the gaussian that match, else 0</p><div class=\"math math-display\">\\begin{aligned} p(x)&#x26;=\\sum_{k=1}^K\\pi_k\\mathcal N(x|\\mu_k,\\Sigma_k)\\\\ \\Sigma_k&#x26;=\\sigma_k^2I \\end{aligned}</div><ul><li><p>if <span class=\"math math-inline\">|x_i-\\mu_k|>2.5\\sigma_k</span> replace least probable gaussian with <span class=\"math math-inline\">\\mathcal N(x_i,\\sigma_k)</span> , high <span class=\"math math-inline\">\\sigma_k</span> small <span class=\"math math-inline\">\\pi_k</span></p></li><li><p>else</p><div class=\"math math-display\">\\begin{aligned} \\pi_k&#x26;=(1-\\alpha)\\pi_k^t+\\alpha M_{k,t}\\\\ \\mu_k^{t+1}&#x26;=(1-\\rho)\\mu_k^t+\\rho x^{t+1}\\\\ \\Sigma_k^{t+1}&#x26;=(1-\\rho)\\Sigma_k^t+\\rho(x^{t+1}-\\mu_k^{t+1})^2\\\\ \\rho&#x26;=\\alpha\\mathcal N(x_n|\\mu_k,\\Sigma_k) \\end{aligned}</div></li><li><p>order the component by <span class=\"math math-inline\">\\frac{\\pi_k}{\\sigma_k}</span>, background <span class=\"math math-inline\">B=argmin_b(\\sum_{k=1}^b\\frac{\\pi_k}{\\sigma_k}\\gt\\tau)</span></p></li></ul><h4>Kernel Background Model</h4><p><span class=\"math math-inline\">x^t</span> : pixel at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">K</span> : kernel function</p><p><span class=\"math math-inline\">\\tau</span> : threshold</p><div class=\"math math-display\">p(x^t)=\\frac{1}{N}\\sum_{i=1}^NK(x^t-x^i)</div><p>foreground if <span class=\"math math-inline\">p(x^t)&#x3C;\\tau</span></p><h2>Template-based tracking</h2><p>wrap and match</p><h3>Lucas Kanade Optical Flow Estimation</h3><h4>Assumption&#x26;Symbols</h4><ul><li>Brightness constancy: the same point looks same everywhere <span class=\"math math-inline\">I(x,y,t)=I(x+dx,y+dy,t+dt)</span></li><li>Small motion: points do not move very far</li><li>Spatial coherence: points move like their neighbors (why we should define a window)</li></ul><p><span class=\"math math-inline\">I</span> : current image</p><p><span class=\"math math-inline\">I_x</span> : current image derivative in row</p><p><span class=\"math math-inline\">I_y</span> : current image derivative in column</p><p><span class=\"math math-inline\">u</span> : small movement in row direction</p><p><span class=\"math math-inline\">v</span> : small movement in column direction</p><p><span class=\"math math-inline\">T</span> : Template image</p><p><span class=\"math math-inline\">W</span> : warpping</p><p><span class=\"math math-inline\">p</span> : warpping parameters</p><p><span class=\"math math-inline\">x</span> : pixel</p><h4>Analytical Solution</h4><p>take a <span class=\"math math-inline\">2\\times2</span> window for an example <span class=\"math math-inline\">I_x</span> represent direvative of all pixels in the window here:</p><div class=\"math math-display\">\\left[\\begin{matrix} I_x(x_0)&#x26;I_y(x_0)\\\\ I_x(x_1)&#x26;I_y(x_1)\\\\ I_x(x_2)&#x26;I_y(x_2)\\\\ I_x(x_3)&#x26;I_y(x_3) \\end{matrix}\\right] \\left[\\begin{matrix} u\\\\v \\end{matrix}\\right]= - \\left[\\begin{matrix} I_t(x_0)\\\\I_t(x_1)\\\\ I_t(x_3)\\\\I_t(x_4) \\end{matrix}\\right]</div><p>normalize as</p><div class=\"math math-display\">\\left[\\begin{matrix} I_x^TI_x&#x26;I_x^TI_y\\\\ I_x^TI_y&#x26;I_y^TI_y \\end{matrix}\\right] \\left[\\begin{matrix} u\\\\v \\end{matrix}\\right]= -\\left[\\begin{matrix} I_x^TI_t\\\\ I_y^TI_t \\end{matrix}\\right]</div><p>problems:</p><ol><li>Errors from non-linear <span class=\"math math-inline\">\\rightarrow</span> iterative LK refinement</li><li>large motions <span class=\"math math-inline\">\\rightarrow</span> coarse-to-fine</li></ol><h4>Numerical Solution</h4><div class=\"math math-display\">L(p)=argmin_p\\sum _x\\left[I(W(x;p))-T(x)\\right]^2\\\\ \\frac{\\partial L(p+\\Delta p)}{\\partial \\Delta p}\\rightarrow 0</div><div class=\"math math-display\">\\begin{aligned} \\Delta p &#x26;= H^{-1}\\sum_{x}[\\gradient I\\frac{\\partial W}{\\partial p}]^T[T(x)-I(W(x;p))]\\\\ J &#x26;= \\frac{\\partial W}{\\partial p} \\\\ H&#x26;=\\sum_x[\\gradient I\\frac{\\partial W}{\\partial p}][\\gradient I \\frac{\\partial W}{\\partial p}] \\\\ p&#x26;\\leftarrow p+\\Delta p \\end{aligned}</div><img src=\"https://s2.loli.net/2022/01/28/e1o9RWcMri4KEDJ.png\" height=\"1077\" width=\"1384\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMElEQVQImWPw9wjjYBTgZhZ6+fIVQ0JQxoxJ8zkYhCf0TGKIC02fPHman0fo////AfV4D00S0DRHAAAAAElFTkSuQmCC\"><h4>Warping Functions</h4><p>Translation : <span class=\"math math-inline\">W([x,y];p)=\\left[\\begin{matrix}x+p_1\\\\y+p_2\\end{matrix}\\right]</span></p><p>Affine: <span class=\"math math-inline\">W([x,y];p)=\\left[\\begin{matrix}x+p_1x+p_3y+p_5\\\\y+p_2x+p_4y+p_6\\end{matrix}\\right]</span></p><p>Perspective : <span class=\"math math-inline\">W([x,y];p)=\\frac{1}{p_7x+p_8y+1}\\left[\\begin{matrix}x+p_1x+p_3y+p_5\\\\y+p_2x+p_4y+p_6\\end{matrix}\\right]</span></p><h4>Shapes</h4><p>Steepest Descend Image : <span class=\"math math-inline\">[H_{template},W_{template},|p|]</span></p><p>Jacobian at <span class=\"math math-inline\">p_0</span> : <span class=\"math math-inline\">[H_{template},W_{template},2,|p|]</span></p><p>Hessian : <span class=\"math math-inline\">[|p|,|p|]</span></p><h4>Improvement&#x26;Cons</h4><p><strong>Iterative LK Refinement</strong></p><ul><li>estimate velocity at each pixel using one iteration of LK estimation</li><li>warp one image toward the other using the estimated flow field</li><li>refine estimate by repeating the process</li></ul><p><strong>Coarse-to-fine</strong> overcome temporal aliasing</p><p>run the LK algorithm iteratively on each image scale in the gaussian pyramid from small to large</p><img src=\"https://s2.loli.net/2022/01/28/zVg92Y5yke6wjCs.png\" height=\"812\" width=\"1344\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMklEQVQImQEnANj/AO7/+/3//ujn8+Pj9gBMtJ+i48Z1bawAAFoAEJSAr+3UXVyfAABYEHEWd4PJdnQAAAAASUVORK5CYII=\"><ul><li>Prone to local minima (why window cannot be big )</li><li>Relatively small movement (why window cannot be small)</li><li>Taylor expansion only valid in a small neighborhood around <span class=\"math math-inline\">p</span></li></ul><h2>Tracking by online classification</h2><p>shift and learn</p><h3>Online Boosting</h3><img src=\"https://s2.loli.net/2022/02/07/SmM3Wxd8jLwo1yN.png\" height=\"816\" width=\"1383\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAI0lEQVQImWPQEJCUZmfvb8mTYBBlqMsrmT158p//H7dtPAAAWTAKXV7MR4wAAAAASUVORK5CYII=\"><p><strong>adaboost</strong></p><h3>Online Classification</h3><img src=\"https://s2.loli.net/2022/02/07/Rv4lnEYfVxeaJyW.png\" height=\"842\" width=\"1320\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMklEQVQImQEnANj/AAAVKHhye//77+7k2QAKABeemKPt393/+fQAAB9YtrHA5dHU7///i3oW22w8akYAAAAASUVORK5CYII=\"><p><strong>problem</strong>: drift</p><p>when the change is slow enough, the classifier adapt to new objects, it still confident about it.</p><p><strong>solution</strong>:</p><ol><li><p>match against initialization</p><p>can't follow appearance changes</p></li><li><p>semi supervised learning</p></li><li><p>using additional cues</p></li></ol><h2>Tracking by detection</h2><p>detect and locate</p><img src=\"https://s2.loli.net/2022/02/07/6woLIntCqzpBKJY.png\" height=\"810\" width=\"1410\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAI0lEQVQImWM4duxwW2urlaWFk5M9AwMjw9t3L9+8efvv/z8AmcsN05sbxakAAAAASUVORK5CYII=\"><h3>SVM based Detectors</h3><h4>HOG</h4><img src=\"https://s2.loli.net/2022/02/07/ER6zprcLuDon1Ai.png\" height=\"387\" width=\"1389\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABCAIAAAB2XpiaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFklEQVQImWNgYGDYv3vX4///C05sAAAjiwb+Gvx88AAAAABJRU5ErkJggg==\"><h4>DPM</h4><img src=\"https://s2.loli.net/2022/02/07/XicJZuLI3GhpRNB.png\" height=\"1070\" width=\"1374\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMElEQVQImWMoLy4QExCsr6/7//8/g3d4GAMPg6ah/cH9BxmOnz5nkeqsaGNz/cZdACjxEE6iPGmgAAAAAElFTkSuQmCC\"><h3>AdaBoost based Detectors</h3><h4>Viola-Jones</h4><img src=\"https://s2.loli.net/2022/02/07/GRCip6DchAEyXfL.png\" height=\"638\" width=\"1325\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAJUlEQVQImQEaAOX/AAAAALu7u4yMiaqqqQA4ODipqanJycn///+SGQ3LA9Zu6QAAAABJRU5ErkJggg==\"><h4>VeryFast</h4><img src=\"https://s2.loli.net/2022/02/07/jCIa4BkvgzQeld8.png\" height=\"499\" width=\"1403\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABCAIAAAB2XpiaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQImWOQlVf9//e3l18oPwMDACCvBFXMl2Z1AAAAAElFTkSuQmCC\"> <img src=\"https://s2.loli.net/2022/02/07/OcVFGKM5N83SWn2.png\" height=\"782\" width=\"1391\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAI0lEQVQImWPQNjZmYGVQVZefPa+H4cuPXx++fvr//8+3b68Ae2gOVOcJAA0AAAAASUVORK5CYII=\"><h3>CNN-based Detectors</h3><h4>R-CNN</h4><img src=\"https://s2.loli.net/2022/02/07/43DerfvEHx8W5Qz.png\" height=\"790\" width=\"1370\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAI0lEQVQImWPYvXvP//+/PJ0s2BkYGFpaWnbv3jN/9vSK0gIAr88M4eRbMhEAAAAASUVORK5CYII=\"> <img src=\"https://s2.loli.net/2022/02/07/8dMmj3hXuWPepI5.png\" height=\"824\" width=\"1202\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAJUlEQVQImQEaAOX/APrr2kMqD8OjlxwABAD48u7SycD///vs5uW5AhA8pB0AHgAAAABJRU5ErkJggg==\"><h1>Bayesian Filtering</h1><div class=\"math math-display\">\\begin{aligned} x_t &#x26;=f(x_{t-1},\\epsilon_{t})\\\\ y_t &#x26;=h(x_t,\\delta_{t}) \\end{aligned}</div><img src=\"https://s2.loli.net/2022/01/28/mjSKPotUd7ZXwxY.png\" height=\"538\" width=\"1198\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIklEQVQImWPIzs4uLy9//PhxdnY2AwMDg5qa2v///6WlpQGRTwpRDMEwYAAAAABJRU5ErkJggg==\"><h2>Kalman Filters</h2><p>predict and correct</p><h3>Symbols</h3><p><span class=\"math math-inline\">x_t</span> : state at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">y_t</span> : observation at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">x_t^-</span> : predicted state at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">x_t^+</span> : corrected state at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">D_t</span> : state transition matrix</p><p><span class=\"math math-inline\">M_t</span> : observation matrix</p><p><span class=\"math math-inline\">\\Sigma_t</span> : state transition covariance at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">\\Sigma_{d_t}</span> : uncertainty of <span class=\"math math-inline\">D_t</span>, usually diagonal</p><p><span class=\"math math-inline\">\\Sigma_{M_t}</span> : uncertainty of <span class=\"math math-inline\">M_t</span>, usually diagonal</p><p><span class=\"math math-inline\">K_t</span> : Kalman gain</p><h3>Solution</h3><p>Assumption:</p><div class=\"math math-display\">\\begin{aligned} x_t &#x26;= D_tx_{t-1}+\\epsilon_t \\\\ y_t &#x26;= M_tx_t+\\delta_t \\end{aligned}</div><p>Predict:</p><div class=\"math math-display\">\\begin{aligned} x_t^- &#x26;= D_tx_{t-1}^+\\\\ \\Sigma_t^-&#x26;=D_t\\Sigma_{t-1}^+D_t^T+\\Sigma_{d_t} \\end{aligned}</div><p>Correct:</p><div class=\"math math-display\">\\begin{aligned} K_t &#x26;= \\Sigma_t^-M_t^T(M_t\\Sigma_t^-M_t^T+\\Sigma_{m_t})^{-1} \\\\ x_t^+&#x26;=x_t^-+K_t(y_t-M_tx_t^-) \\\\ \\Sigma_t^+&#x26;=(I-K_tM_t)\\Sigma_t^- \\end{aligned}</div><p>some example of <span class=\"math math-inline\">D_t</span></p><ul><li>constant velocity <span class=\"math math-inline\">\\left[\\begin{matrix}I&#x26;\\Delta tI\\\\\\bold 0&#x26;I\\end{matrix}\\right]</span></li><li>constant acceleration <span class=\"math math-inline\">\\left[\\begin{matrix}I&#x26;\\Delta tI&#x26;\\frac{1}{2}\\Delta t^2I\\\\\\bold 0&#x26;I&#x26;\\bold \\Delta tI\\\\\\bold 0&#x26;\\bold 0&#x26;I\\end{matrix}\\right]</span></li></ul><p>Dynamics model : <span class=\"math math-inline\">x_t\\sim \\mathcal N(D_tx_{t-1},\\Sigma_{d_t})</span> Observation model : <span class=\"math math-inline\">y_t\\sim \\mathcal N(M_tx_t,\\Sigma_{m_t})</span></p><h3>Improvement</h3><p><strong>Extended Kalman Filter</strong></p><p>Assumption:</p><div class=\"math math-display\">\\begin{aligned} x_t &#x26;= g(x_{t-1})+\\epsilon_t \\\\ y_t &#x26;= h(x_t)+\\delta_t \\end{aligned}</div><p>Prediction:</p><div class=\"math math-display\">\\begin{aligned} x_t^- &#x26;= g(x_{t-1}^+) \\\\ \\Sigma_t^- &#x26;= G_t\\Sigma_{t-1}^+G_t^T+\\Sigma_{d_t} \\\\ G_t &#x26;= \\left.\\frac{\\partial g(x)}{\\partial x}\\right|_{x=x_{t-1}^+} \\end{aligned}</div><p>Correction:</p><div class=\"math math-display\">\\begin{aligned} K_t &#x26;= \\Sigma_t^-H_t^T(H_t\\Sigma_t^-H_t^T+\\Sigma_{m_t})^{-1} \\\\ x_t^+&#x26;=x_t^-+K_t(y_t-h(x_t^-)) \\\\ \\Sigma_t^+&#x26;=(I-K_tH_t)\\Sigma_t^- \\\\ H_t&#x26;=\\left.\\frac{\\partial h(x)}{\\partial x}\\right|_{x=x_t^-} \\end{aligned}</div><h2>Particle Filters</h2><p>predict and correct</p><img src=\"https://s2.loli.net/2022/01/29/NXCbVFjGhAx5ilt.png\" height=\"913\" width=\"1757\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAHUlEQVQImWP4/////fv3////f+PmTYZWGGBgYAAAAAkPz7qxlrgAAAAASUVORK5CYII=\"><h3>Symbols</h3><p><span class=\"math math-inline\">x_t</span> : state at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">y_t</span> : observation at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">y_{1:t-1}</span> : observations from time <span class=\"math math-inline\">1</span> to time <span class=\"math math-inline\">t-1</span></p><p><span class=\"math math-inline\">w_t^i</span> : weight of particle <span class=\"math math-inline\">i</span> at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">\\tilde{w_t^i}</span> : unnormalized weight of particle <span class=\"math math-inline\">i</span> at time <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">p(x_t|x_{t-1}^i)</span> : probability density function of <span class=\"math math-inline\">x_t</span> under the condition of <span class=\"math math-inline\">x_{t-1}^i</span></p><p><span class=\"math math-inline\">N_{eff}</span> : effective sample size <span class=\"math math-inline\">N_{eff}\\propto\\frac{1}{\\sum(w_t^i)^2}</span></p><h3>Solution</h3><p>Assumption:</p><div class=\"math math-display\">\\begin{aligned} P(x_t|y_{1:t-1}) &#x26;= \\int_{dx_{t-1}}P(x_t|x_{t-1})P(x_{t-1}|y_{1:t-1})dx_{t-1}\\\\ P(x_t|y_{1:t})&#x26;\\propto P(y_t|x_t)P(x_t|y_{1:{t-1}}) \\end{aligned}</div><p>Monte-Carlo sampling</p><div class=\"math math-display\">E(f(x))\\approx\\frac{1}{N}\\sum_{n=1}^Nf(x_n)</div><p>Sequence Importance Sampling (if not most particles have negligible weights)</p><div class=\"math math-display\">\\begin{aligned} \\tilde{w_t^i}&#x26;=w_{t-1}^ip(y_t|x_t^i)\\\\ x_t^i&#x26;\\sim p(x_t|x_{t-1}^i)\\\\ w_t^i&#x26;=\\frac{\\tilde{w_t^i}}{\\sum_{i=1}^N \\tilde{w_t^i}} \\end{aligned}</div><p>Sampling Importance Resampling</p><div class=\"math math-display\">\\hat{x_t^i}\\sim p(x_t|x_{t-1}^i)\\\\ x_t^{1:N}=\\{\\hat{x_t^i}|i\\sim p(y_t|\\hat{x_t^i})\\}</div><p>Particle Filtering</p><ol><li><span class=\"math math-inline\">x_t^{1:N},w_t^{1:N}=SIS(x_{t-1}^{1:N},w_{t-1}^{1:N},y_t)\\\\</span></li><li><span class=\"math math-inline\">if\\quad N_{eff}&#x3C;N_{thr}\\quad x_t^{1:N},w_t^{1:N}=resample(x_t^{1:N},w_t^{1:t})</span></li></ol><h3>discussion</h3><p>pros:</p><ul><li>represent arbitrary distribution compared to KF</li><li>keep track of as many hypotheses as there are particles</li><li>multimodal support</li></ul><h1>Multi-Object Tracking</h1><p>predict and match</p><h2>NN Assignment</h2><img src=\"https://s2.loli.net/2022/02/04/aFNI8sOVeAqow5h.png\" height=\"487\" width=\"650\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMklEQVQImQEnANj/AP///4eNko6Xlfv8+wDU1s8TAABkbHD3+fcAjYV8U09IkJaa7Ovq1HsW/E18EogAAAAASUVORK5CYII=\"><h3>Symbols</h3><p><span class=\"math math-inline\">x_l</span> : track <span class=\"math math-inline\">l</span></p><p><span class=\"math math-inline\">x_l^{(k)}</span> : prediction</p><p><span class=\"math math-inline\">\\Sigma_{p,l}^{(k)}</span> : covariance of <span class=\"math math-inline\">x_l^{(k)}</span></p><h3>Solution</h3><p>innovation : <span class=\"math math-inline\">v_{j,l}^{(k)}=(y_j^{(k)}-x_{p,l}^{(k)})</span></p><p>gating or validation volumne : <span class=\"math math-inline\">V^{(k)}(\\gamma)=\\{y|(y-x_{p,l}^{(k)})^T\\Sigma_{p,l}^{(k)-1}(y-x_{p,l}^{(k)})\\le\\gamma\\}</span></p><h3>Discussion</h3><ol><li>too small validation volume <span class=\"math math-inline\">\\rightarrow</span> permaturly end tracks</li><li>too big validation volume <span class=\"math math-inline\">\\rightarrow</span> tracks may not end</li></ol><h2>Track Splitting Filter</h2><div class=\"math math-display\">\\lambda_l(k)=\\lambda_l(k-1)+{v_{i_k,l}^k}^T{\\Sigma_l^k}^{-1}v_{i_k,l}^k</div><h3>pruning</h3><ul><li>delete unlike tracks</li><li>marge track nodes</li><li>keep most likely N tracks</li></ul><h2>Multi Hypothesis Tracking</h2><p>Linear Assignment Problem</p><h3>Solution</h3><p>Nearest Neighbor Matching</p><p>find nearest neighbor within gating <span class=\"math math-inline\">\\gamma</span></p><ul><li><p>Greedy Algorithm</p><p>cannot find the optimal solution</p></li><li><p>Hungarian Algorithm</p><p>Also known as <strong>Kuhn-Munkres Algorithm</strong></p><p>complexity: <span class=\"math math-inline\">O(n^3)</span></p></li></ul><h2>Network Flow Optimization</h2><img src=\"https://s2.loli.net/2022/01/29/o3XfvSeAr5kgCda.png\" height=\"908\" width=\"1230\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAMklEQVQImQEnANj/AOfn5RsYFH5+f5+fnwD///+AgINGREXExMQA7unohoSGBQAAj46MlkET67j2F/8AAAAASUVORK5CYII=\"><h3>Symbols</h3><p><span class=\"math math-inline\">\\beta</span> : false alarm rate</p><p><span class=\"math math-inline\">C_i</span> : <span class=\"math math-inline\">C_i=log\\frac{\\beta_i}{1-\\beta_i}</span> likelihood of detection of edge <span class=\"math math-inline\">i</span></p><h3>Solution</h3><div class=\"math math-display\">\\tau = argmin(\\sum_i C_{in,i}f_{in,i}+\\sum_i C_{i,out}f_{i,out}+\\sum_{i,j}C_{i,j}f_{i,j}+\\sum_i C_if_i)</div><h3>Pros&#x26;limitations</h3><ul><li>Pros<ol><li>efficient algorithms available</li><li>global optimal solution</li></ol></li><li>Limitations<ol><li><p><span class=\"math math-inline\">C_{in},C_{out}</span> too low <span class=\"math math-inline\">\\Rightarrow</span> fragmentations</p></li><li><p><span class=\"math math-inline\">C_{in},C_{out}</span> too high <span class=\"math math-inline\">\\Rightarrow</span> ID switches</p></li></ol></li></ul><h1>Visual Odometry</h1><p>sensor type:</p><ul><li>monocular cameras</li><li>stereo camera (left+right)</li><li>RGB-D sensors (depth)</li></ul><h2>Lie Group</h2><h3>Definition&#x26;Symbols</h3><p><span class=\"math math-inline\">w</span> : vector of elements in <span class=\"math math-inline\">\\hat{w}</span>, <span class=\"math math-inline\">w\\in \\mathbb R^3</span> ,</p><p><span class=\"math math-inline\">so(3)</span> : space of skew-symmetric matrices <span class=\"math math-inline\">so(3)=\\left\\{\\hat{w}\\in \\mathbb R^{3\\times3}|w\\in \\mathbb R^3\\right\\}</span></p><p><span class=\"math math-inline\">SO(3)</span> : special orthogonal group <span class=\"math math-inline\">SO3=\\left\\{R\\in\\mathbb R^3|R^TR=I,|R|=1\\right\\}</span></p><p><span class=\"math math-inline\">\\hat{\\xi}</span> : twist , <span class=\"math math-inline\">\\hat{\\xi}\\in se(3)</span> , <span class=\"math math-inline\">\\hat{\\xi} \\in \\mathbb R^{3\\times 3}</span></p><p><span class=\"math math-inline\">SE(3)</span> : special euclidean transformation (rigid body motion)<span class=\"math math-inline\">SE(3)=\\{g=\\left[\\begin{matrix}R&#x26;T\\\\0&#x26;1\\end{matrix}\\right]|R\\in SO(3),T\\in\\mathbb R^3\\}</span></p><p><span class=\"math math-inline\">se(3)</span> : tangent space (Le algebra) <span class=\"math math-inline\">se(3)=\\left\\{\\left.\\hat{\\xi}\\in\\left[\\begin{matrix}\\hat{w}&#x26;v\\\\0&#x26;0\\end{matrix}\\right]\\right|\\hat{w}\\in so(3),v\\in\\mathbb R^3\\right\\}</span></p><h3>Formula</h3><div class=\"math math-display\">\\begin{aligned} R(t)&#x26;=e^{\\hat{w}t}\\\\ \\hat{w} &#x26;= log(R)\\\\ g(t)&#x26;=e^{\\hat{\\xi}t} =\\left[\\begin{matrix} e^{\\hat{w}}&#x26;\\frac{(I-e^{\\hat{w}})\\hat{w}v+ww^Tv}{||w||}\\\\ 0&#x26;1 \\end{matrix}\\right] \\end{aligned}</div><div class=\"math math-display\">||w||=cos^{-1}(\\frac{trace(R)-1}{2})\\\\ \\frac{w}{||w||}=\\frac{1}{2sin(||w||)}\\left[\\begin{matrix}r_{32}-r_{23}\\\\r_{13}-r_{31}\\\\r_{21}-r_{12}\\end{matrix}\\right]</div><p><span class=\"math math-inline\">R</span> could be considered as rotation around vector <span class=\"math math-inline\">w</span> by angle <span class=\"math math-inline\">||w||</span></p><div class=\"math math-display\">R=I+\\frac{\\hat{w}}{||w||}sin(||w||)+\\frac{\\hat{w}^2}{||w||}\\left(1-cos(||w||)\\right)</div><div class=\"math math-display\">\\begin{aligned} \\hat{w}^2 &#x26;= ww^T-I\\\\ \\hat{w}^3 &#x26;=-\\hat w \\end{aligned}</div><p>transition</p><div class=\"math math-display\">\\begin{aligned} se(3)\\rightarrow se(3)&#x26;:\\hat{\\xi}\\rightarrow g\\hat{\\xi}g^{-1}\\\\ so(3)\\rightarrow so(3)&#x26;:\\hat{w}\\rightarrow R\\hat{w}R^T \\end{aligned}</div><h2>Indirect Visual Odometry</h2><p><span class=\"math math-inline\">E(\\xi)=\\sum_i|y_{1,i}-w(y_{2,i},\\xi)|</span></p><p>reprojection error</p><h3>Symbols</h3><p><span class=\"math math-inline\">E(\\xi)</span> : Error function with parameter <span class=\"math math-inline\">\\xi</span></p><p><span class=\"math math-inline\">u</span> : pixel</p><p><span class=\"math math-inline\">w(u,\\xi)</span> : warp operation on pixel <span class=\"math math-inline\">u</span> with parameter <span class=\"math math-inline\">\\xi</span></p><h3>2D-to-2D(eight point algorithm)</h3><h4>Definition&#x26;Symbols</h4><p>given corresponding image point observations</p><p><span class=\"math math-inline\">Y_t = \\{y_{t,1:N}\\}</span></p><p><span class=\"math math-inline\">Y_{t-1}=\\{y_{t-1,1:N}\\}</span></p><p>of unknown 3D points <span class=\"math math-inline\">X=\\{x_{1:N}\\}</span></p><p>determine the relative motion <span class=\"math math-inline\">T_t^{t-1}</span></p><p><span class=\"math math-inline\">E</span> : essential matrix</p><p><span class=\"math math-inline\">y</span> : observation</p><p><span class=\"math math-inline\">t</span> : transition vector</p><p><span class=\"math math-inline\">R</span> : rotation matrix</p><h4>Solution</h4><p><strong>epipolar constraint</strong> : <span class=\"math math-inline\">\\tilde{y}^T(t\\times R\\tilde y')=0</span></p><ol><li><p>obtain the approximate essential matrix <span class=\"math math-inline\">\\tilde{E}</span></p><p><span class=\"math math-inline\">E=t\\times R=\\hat{t}R</span> <span class=\"math math-inline\">\\tilde{y_i}\\tilde{E}\\tilde{y_i}'=AE_s\\rightarrow0</span></p><p>Lagrange multipliersï¼š(set constraint as <span class=\"math math-inline\">||E_s||=1</span>)</p><p><span class=\"math math-inline\">L(E_s,A)=||AE_s||^2+\\lambda(1-||E_s||^2)</span></p><p><span class=\"math math-inline\">\\because \\frac{\\partial L}{\\partial E_s}\\Rightarrow A^TAE_s=\\lambda E_s</span></p><p><span class=\"math math-inline\">\\therefore</span> <span class=\"math math-inline\">E_s</span> is the eigen vector correspondent to singular value <span class=\"math math-inline\">\\lambda</span> for <span class=\"math math-inline\">A</span></p><p><span class=\"math math-inline\">\\because ||AE_s||^2=\\lambda</span></p><p><span class=\"math math-inline\">\\therefore</span> <span class=\"math math-inline\">\\lambda</span> is the smallest singular value of <span class=\"math math-inline\">A</span></p></li><li><p>project <span class=\"math math-inline\">\\tilde{E}</span> to Lie group, let <span class=\"math math-inline\">(R,t)\\in SE(3)</span></p><p><span class=\"math math-inline\">\\tilde E = Udiag(\\sigma_1,\\sigma_2,\\sigma_3)V^T</span></p><p><span class=\"math math-inline\">E=Udiag(1,1,0)V^T</span></p></li><li><p>restore <span class=\"math math-inline\">R</span> and <span class=\"math math-inline\">t</span></p><p><span class=\"math math-inline\">R=UR_z^T(\\pm\\frac{\\pi}{2})V^T</span></p><p><span class=\"math math-inline\">\\hat{t}=UR_z(\\pm\\frac{\\pi}{2})diag(1,1,0)U^T</span></p></li><li><p>calc depth <span class=\"math math-inline\">d</span></p><p><span class=\"math math-inline\">\\lambda' y'=\\lambda Ry+\\gamma t</span></p><p><span class=\"math math-inline\">\\lambda \\hat{y}'Ry+\\gamma\\hat{y}'t\\rightarrow 0</span></p><p><span class=\"math math-inline\">\\left[\\begin{matrix}\\hat{y_1}'Ry_1&#x26;0&#x26;0&#x26;\\hat{y_1}'t\\\\0&#x26;\\hat{y_2}'Ry_2&#x26;0&#x26;\\hat{y_2}'t\\\\0&#x26;0&#x26;\\ddots&#x26;\\vdots\\\\0&#x26;0&#x26;\\hat{y_n}'Ry_n&#x26;\\hat{y_n}'t\\end{matrix}\\right]\\left[\\begin{matrix}\\lambda_1\\\\\\lambda_2\\\\\\vdots\\\\\\lambda_n\\\\\\gamma\\end{matrix}\\right]\\rightarrow 0</span></p><p><span class=\"math math-inline\">d_i=\\frac{\\lambda_i}{\\gamma}</span></p><p>filter with positive depth</p></li></ol><h4>Drift</h4><p>errors accumulate</p><p>select keyframes to solve this problem</p><img src=\"https://s2.loli.net/2022/01/30/bnSrWQuV5vR2FBl.png\" height=\"1187\" width=\"1127\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAP0lEQVQImQE0AMv/AHdraQkAFUFCU////wCrpaQ/O0Fra3L///0Am5ubvb28h4eGq6urAHl4eGRlZWdnaOPj43rOGkE7+wNmAAAAAElFTkSuQmCC\"><h3>2D-to-3D(Perspective-n-Points)</h3><h4>Definition&#x26;Symbols</h4><p>given 3D points <span class=\"math math-inline\">X=\\{x_{1:N}\\}</span></p><p>and corresponding image <span class=\"math math-inline\">Y_t=\\{y_{t,1:N}\\}</span></p><p>determine camera pose <span class=\"math math-inline\">T_t</span></p><p><span class=\"math math-inline\">P</span> : projection matrix <span class=\"math math-inline\">P=(\\begin{matrix}R&#x26;t\\end{matrix})\\in \\mathbb R^{3\\times4}</span></p><h4>Solution</h4><p><strong>constraint</strong> : <span class=\"math math-inline\">\\tilde y_i\\times(P\\tilde x_i)</span></p><h3>3D-to-3D</h3><h2>Direct Methods</h2><p><span class=\"math math-inline\">E(\\xi)=\\int_{u}|I_1(u)-I_2(w(u,\\xi))|du</span></p><p>photometric error</p><p>don't need to extract keypoint, but need depth</p><h3>Symbols</h3><p><span class=\"math math-inline\">\\xi</span> : twist parameters of transformation, <span class=\"math math-inline\">\\xi \\in \\mathbb R^6</span></p><p><span class=\"math math-inline\">C</span> : camera projection matrix, <span class=\"math math-inline\">C\\in \\mathbb R^{3\\times3}</span></p><p><span class=\"math math-inline\">d_{ij}</span> : depth of pixel at row <span class=\"math math-inline\">i</span> column <span class=\"math math-inline\">j</span> , <span class=\"math math-inline\">d_{ij}\\in \\mathbb R</span></p><p><span class=\"math math-inline\">p_{ij}</span> : 3D position of pixel at row <span class=\"math math-inline\">i</span> column <span class=\"math math-inline\">j</span>, <span class=\"math math-inline\">p_{ij}\\in \\mathbb R^3</span></p><p><span class=\"math math-inline\">I_{ij}</span> : 2D pixel value at row <span class=\"math math-inline\">i</span> column <span class=\"math math-inline\">j</span>, <span class=\"math math-inline\">I_{ij}\\in \\mathbb R^2</span></p><p><span class=\"math math-inline\">X_{i}</span> : x position of <span class=\"math math-inline\">p_{ij}</span> in projected image</p><p><span class=\"math math-inline\">Y_i</span> : y position of <span class=\"math math-inline\">p_{ij}</span> in the projected image</p><p><span class=\"math math-inline\">W</span> : weight, given diagonal matrix</p><h3>Solution</h3><p>twist coordinate to <span class=\"math math-inline\">SE(3)</span> : <span class=\"math math-inline\">T=\\left[\\begin{matrix}0&#x26;-\\xi_6&#x26;\\xi_5&#x26;\\xi_1\\\\\\xi_6&#x26;0&#x26;\\xi_4&#x26;\\xi_2\\\\-\\xi_5&#x26;\\xi_4&#x26;0&#x26;\\xi_3\\\\0&#x26;0&#x26;0&#x26;1\\end{matrix}\\right]</span></p><p>location of pixel in image to 3D points in image : <span class=\"math math-inline\">p_{ij}=d_{ij}C^{-1}\\left[\\begin{matrix}i\\\\j\\\\1\\end{matrix}\\right]</span></p><p>location of 3D point of image1 in image2: <span class=\"math math-inline\">\\left[\\begin{matrix}\\lambda X_i'\\\\\\lambda Y_j'\\\\\\lambda\\\\1\\end{matrix}\\right]=CT\\left[\\begin{matrix}p_{ij}\\\\1\\end{matrix}\\right]</span></p><p>residual value : <span class=\"math math-inline\">r=I'-interpolate(X',Y',I)</span></p><p>geometric error : compare in depth</p><p>photometric error : compare in <span class=\"math math-inline\">I</span></p><p>optimize residual:</p><div class=\"math math-display\">\\xi_{i+1}=\\xi_i-H_i^{-1}J_i^TWr(\\xi_i)\\\\ J_i=\\nabla_\\xi r(\\xi_i)\\\\ H_i=J_i^TWJ_i</div><h1>Visual SLAM</h1><img src=\"https://s2.loli.net/2022/02/04/Sole19mqMypHXZj.png\" width=\"1288\" height=\"560\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABCAIAAAB2XpiaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFUlEQVQImWNIio7hYmB4dPfu////AR+LBr0jK8jmAAAAAElFTkSuQmCC\"><h2>EKF SLAM</h2><h3>Symbols</h3><p><span class=\"math math-inline\">u</span> : uncertain action</p><p><span class=\"math math-inline\">\\xi</span> : actual pose, composed of position <span class=\"math math-inline\">p\\in\\mathbb R^2</span> and direction <span class=\"math math-inline\">\\theta\\in\\mathbb R^1</span> (take 2D for example)</p><p><span class=\"math math-inline\">x</span> : hidden status</p><p><span class=\"math math-inline\">g</span> : transition function</p><p><span class=\"math math-inline\">m</span> : landmarks</p><p><span class=\"math math-inline\">y</span> : observations</p><h3>Solution</h3><div class=\"math math-display\">x_t = g(x_{t-1},u_t)+\\epsilon_t, \\epsilon_t\\sim \\mathcal N(0,\\Sigma_{d_t,\\xi}) \\\\ g(x_{t-1},u_t) = \\left(\\begin{matrix} g_\\xi(\\xi_{t-1},u_t)\\\\g_m(m_{t-1}) \\end{matrix}\\right) \\\\ \\Sigma_{d_t}=\\left(\\begin{matrix} \\Sigma_{d_t,\\xi}&#x26;0\\\\ 0&#x26;0 \\end{matrix}\\right)</div><div class=\"math math-display\">y_t = h(\\xi_t,m_{t,c_t})+\\delta_t,\\delta_t\\sim\\mathcal N(0,\\Sigma_{m_t}) \\\\ h(\\xi_t,m_{t,c_t})=\\left(\\begin{matrix} ||m_{t,c_t}^{rel}||_2\\\\ atan2(m_{t,c_t,y}^{rel},m_{r,c_t,x}^{rel})\\\\ m_{t,c_t}^rel=R(-\\theta_t)(m_{t,c_t}-p) \\end{matrix}\\right)</div><h3>Discussion</h3><p>shape of state vector : <span class=\"math math-inline\">|\\xi|+|m|\\times n\\_landmark</span></p><p>for MonoSLAM : <span class=\"math math-inline\">(3+3+2)+3*n\\_landmark</span></p><p>Cons:</p><ul><li>covariance matrix is huge</li></ul><h2>Full SLAM</h2><p>optimize for whole trajectory and all landmarks at once</p><p>SLAM graph optimization</p><p>pose graph optimization</p><h1>Deep Learning</h1><h2>Siamese network</h2><img src=\"https://s2.loli.net/2022/02/18/agVFJuU485EAb1h.jpg\" style=\"zoom:25%;\" width=\"1136\" height=\"1042\" type=\"jpg\" blurdataurl=\"data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAEAAQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAX/xAAgEAABAwMFAQAAAAAAAAAAAAACAAEEAwUGERIiIzGR/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ALk/H5tjqg9ryzJo73AGnSdsseysWrEb8PXYR+IiIP/Z\"><h2>Loss</h2><p>for learning similarity (<strong>Siamese network</strong>)</p><h3>contrastive loss</h3><div class=\"math math-display\">||f(x)-f(x_+)||\\rightarrow 0 \\\\ ||f(x)-f(x_-)||\\ge m</div><h3>triplet loss</h3><p>group positive examples closer to the anchor than the negative one</p><div class=\"math math-display\">||f(x_i^a)-f(x_i^p)||_2^2\\lt ||f(x_i^a)-f(x_i^n)||_2^2</div><h3>FlowNet</h3><p>compare to LK-flow</p><p>+ more precise</p><p>+ no need to design window and warping function</p><p>- need trainig dataset</p><p><img src=\"https://img-blog.csdn.net/20171007194106462\" alt=\"img\" width=\"1171\" height=\"253\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABCAIAAAB2XpiaAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAFklEQVQImWNgYOZv6p74+v2n7///AwAhfAdyVP55+AAAAABJRU5ErkJggg==\"></p><img src=\"https://s2.loli.net/2022/02/09/sX41LHhVZTxP23j.png\" width=\"1919\" height=\"625\" type=\"png\" blurdataurl=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABCAIAAAB2XpiaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAFklEQVQImWNgYOHvmzJjx54DP///BwAfeQb5GaubvQAAAABJRU5ErkJggg==\"><p><strong>refinement</strong></p><ul><li>refine coarse pooled representation by upconvolution layers</li><li>skep connections to preserve high-res information from early layers</li></ul>","renderType":"md","imageProps":{"src":"https://s2.loli.net/2022/06/18/8XYy9qx5zKhnBmg.png","width":1400,"height":906,"type":"png","blurDataURL":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAL0lEQVQImWNwsbAqykjsailmYGJg6CuKWT6pfnJD2v//VxnibDQS3HQt1PkMDeQAEF4NVs7wZXsAAAAASUVORK5CYII="},"language":"en"},"__N_SSG":true}